# -*- coding: utf-8 -*-
"""GraphML1_ГордееваНГ.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1p1fDRIoo3pssf-CMstQUEuyTfuvqE3vf

# NetworkX
"""

import numpy as np
import matplotlib.pyplot as plt
import networkx as nx
nx.__version__

"""Мы рассмотрим некоторые основы NetworkX. Дополнительную информацию можно найти в [документации NetworkX](https://networkx.github.io/documentation/stable/), которая включает в себя [руководство](https://networkx.github.io/documentation/stable/tutorial.html).

Сначала создадим простой граф:
"""

G = nx.Graph()

# add nodes
G.add_node(0, name="dog")
G.add_node(1)
G.add_nodes_from(range(3)) # adds nodes 0, 1

# add edge from node 0 to node 1
G.add_edge(0,1)

# draws the graph to pyplot axes
nx.draw(G, with_labels=True, font_weight='bold')
plt.show()

"""Узлы графа могут быть любыми объектами:"""

G = nx.Graph()

# add nodes
G.add_node("dog")
G.add_node("cat")

# add edge
G.add_edge("cat","dog")

# draws the graph to pyplot axes
nx.draw(G, with_labels=True)
plt.show()

"""Можно связать произвольные данные с каждым узлом и ребром, передав аргументы ключевого слова"""

G = nx.Graph()

# add nodes
G.add_node("dog", name="Rover", weight=10.0)
G.add_node("cat", name="Felix", height=5)

# add edge
G.add_edge("cat","dog", time=2.0)

# draws the graph to pyplot axes
nx.draw(G, with_labels=True, labels=nx.get_node_attributes(G, "name"))
plt.show()

G.get_edge_data("cat", "dog")

nx.get_edge_attributes(G, "time")

names = nx.get_node_attributes(G, "name")
names

weights = nx.get_node_attributes(G, "weight")
weights

"""## Генерация графов

NetworkX предоставляет [графовые генераторы](https://networkx.github.io/documentation/stable/reference/generators.html) для создания различных случайных графов.

### Случайный граф Эрдоса-Реньи

Случайный граф Эрдоса-Реньи
$G_{n,p}$ - это граф на $n$ узлах, в котором вероятность существования ребра $(i,j)$ равна $p$.
В NetworkX такой граф называется `gnp`-графом.
"""

n = 50
p = 5 / (n-1) # 5 is expected number of neighbors of a single vertex
G = nx.gnp_random_graph(n, p)
nx.draw(G, with_labels=False)
plt.title(r'$G({},{})$'.format(n,p))
plt.show()

"""### Стохастические блочные модели

Граф, построенный на основе стохастической блочной модели (SBM, Stochastic Block Models)
имеет $k$ кластеров и $k\times k$ (симметричную) матрицу $P$ вероятностей, где $P_{i,j}$ - вероятность того, что пара узлов $(a,b)$ будет соединена ребром, если $a$ находится в кластере $i$, а $b$ - в кластере $j$.
"""

ns = [25, 25, 25] # size of clusters
ps = [[0.3, 0.01, 0.01], [0.01, 0.3, 0.01], [0.01, 0.01, 0.3]] # probability of edge
G = nx.stochastic_block_model(ns, ps)
nx.draw(G, with_labels=False)
plt.show()

"""## Визуализация

Визуализация графов часто является отличным способом увидеть и понять информацию.

Если не существует какого-то "истинного" способа расположения узлов (то есть каждый узел имеет связанную с ним координату), мы должны выбрать какой-то способ размещения узлов в нашей визуализации.  Для этого существует множество методов.

Существует несколько методов компоновки, которые можно использовать для определенных задач.

### Спектральные эмбединги (Spectral Embeddings)

Спектральные эмбединги подходят для разбиения графа на кластеры.
"""

nx.draw_spectral(G)
plt.show()

"""### Пружинные макеты (Spring layouts)

Пружинные макеты, как правило, хорошо разделяют узлы, что может быть полезно для визуализации
"""

nx.draw_spring(G)
plt.show()

"""### Алгоритм Камада-Кавай

Алгоритм Камада-Кавай ([Kamada-Kawai algorithm](https://www-sciencedirect-com.proxy.uchicago.edu/science/article/pii/0020019089901026?via%3Dihub)) также полезен для визуализации
"""

nx.draw_kamada_kawai(G)
plt.show()

pos = nx.kamada_kawai_layout(G)
pos

"""### Граф с круговым расположением (circular layout)"""

nx.draw_circular(G)

"""## Алгоритмы

NetworkX реализует различные алгоритмы работы с графами.

### Кратчайшие пути

Путь между узлами $x$ и $y$ - это последовательность ребер, в которой конец одного ребра является началом следующего ребра.
\begin{equation}
(x, v_0), (v_0, v_1), \dots, (v_k, y)
\end{equation}
Длина пути - это количество ребер в последовательности.  Кратчайший путь - это путь с наименьшей длиной среди всех возможных путей.

Рассмотрим на двумерной плоскости:
"""

G = nx.grid_2d_graph(10,10)
pos = nx.kamada_kawai_layout(G)
nx.draw(G, pos, with_labels=True)

pos = {(i,j): np.array([i,j]) for i in range(10) for j in range(10)}
nx.draw(G, pos, with_labels=True)

"""Узлы индексируются координатами $(i,j)$."""

p = nx.shortest_path(G, (0,0), (9,9))
elist = [[p[i], p[i+1]] for i in range(len(p)-1)]
nx.draw(G, pos)
nx.draw_networkx_edges(G, pos, elist, edge_color='r', width=3.0)
plt.show()

"""Длина кратчайшего пути между любыми двумя вершинами в графе $G$ определяет метрику на множестве вершин (аналог геодезической метрики на многообразии).

Создадим итератор по длине кратчайшего пути для каждого узла:
"""

dists = nx.shortest_path_length(G)
dists = list(dists)
dists[0][0], dists[0][1]

"""### Упражнение

Напишите функцию, которая возвращает матрицу расстояний для длины кратчайшего пути.
"""

def distance_matrix(graph):
    # Получаем все пары кратчайших путей
    lengths = dict(nx.all_pairs_shortest_path_length(graph))

    # Извлекаем количество узлов
    nodes = list(graph.nodes())
    n = len(nodes)

    # Создаем матрицу расстояний
    dist_matrix = np.zeros((n, n))

    # Заполняем матрицу расстояний
    for i, node_i in enumerate(nodes):
        for j, node_j in enumerate(nodes):
            dist_matrix[i][j] = lengths[node_i].get(node_j, float('inf'))

    return dist_matrix

# Пример использования
G = nx.grid_2d_graph(10, 10)
dist_matrix_result = distance_matrix(G)

print("Матрица расстояний:")
print(dist_matrix_result)

"""### Охватывающие деревья (Spanning Trees)

Дерево - это связный граф без циклов.
Если граф имеет $n$ узлов, то для того, чтобы быть деревом, он должен иметь $m = n-1$ ребер.

Охватывающее дерево графа $G$ - это подграф с тем же набором вершин и подмножеством ребер, который образует дерево.  Минимальное охватывающее дерево (MST, minimum spanning tree) - это охватывающее дерево с минимальным весом (вы можете взвесить ребра с помощью атрибута `weight`).

Можно вычислить охватывающее дерево графа, используя `nx.tree.minimum_spanning_tree` или `nx.tree.minimum_spanning_edges`.
Предусмотрены и другие алгоритмы вычисления деревьев (https://networkx.org/documentation/stable/reference/algorithms/tree.html).
"""

T = nx.tree.minimum_spanning_tree(G)

nx.draw(G, pos)
nx.draw(T, pos, edge_color='r', width=3.0)
plt.show()

# set random weights
for i,j in G.edges():
    G[i][j]['weight'] = np.random.rand()


T = nx.tree.minimum_spanning_tree(G)

# nx.draw(G, pos, )
nx.draw(T, pos, edge_color='r', width=3.0)
plt.show()

"""### Упражнение

Создайте функцию, которая генерирует лабиринт на двумерной плоскости $m \times n$ с помощью `nx.grid_2d_graph` и случайного взвешенного минимального охватывающего дерева.  Поместите начальную и конечную точки в $(0,0)$ и $(m-1, n-1)$ соответственно.

Создайте функцию, которая решает лабиринт, вычисляя кратчайший путь между начальной и конечной точками.
"""

import numpy as np
import networkx as nx
import matplotlib.pyplot as plt

def generate_maze(m, n):
    # Создаем 2D граф
    G = nx.grid_2d_graph(m, n)

    # Устанавливаем случайные веса для рёбер
    for i, j in G.edges():
        G[i][j]['weight'] = np.random.rand()

    # Находим минимальное остовное дерево
    T = nx.tree.minimum_spanning_tree(G)

    # Сохраняем размеры графа как атрибуты
    G.graph['m'] = m
    G.graph['n'] = n

    return G, T

def solve_maze(G):
    start = (0, 0)
    end = (G.graph['m'] - 1, G.graph['n'] - 1)  # Конечная точка (m-1, n-1)

    # Находим кратчайший путь в минимальном остовном дереве
    path = nx.shortest_path(G, source=start, target=end, weight='weight')

    return path

def draw_maze(G, T, path=None):
    pos = {(i, j): (j, -i) for i in range(G.graph['m']) for j in range(G.graph['n'])}

    # Рисуем граф
    plt.figure(figsize=(8, 8))
    nx.draw(G, pos, node_color='lightgrey', with_labels=True)

    # Рисуем минимальное остовное дерево
    nx.draw(T, pos, edge_color='r', width=3.0)

    # Если есть путь, рисуем его
    if path:
        path_edges = [(path[i], path[i + 1]) for i in range(len(path) - 1)]
        nx.draw_networkx_edges(G, pos, edgelist=path_edges, edge_color='b', width=3.0)

    plt.title("Maze with Minimum Spanning Tree and Shortest Path")
    plt.show()

# Пример использования
m, n = 10, 10
G, T = generate_maze(m, n)
path = solve_maze(G)

draw_maze(G, T, path)

"""### Двудольные графы

Двудольный граф - это граф, в котором вершины разделены на два множества $U, V$, а ребра имеют вид $(u,v)$ с $u\in U$ и $v\in V$
(нет ребер между двумя точками в $U$ или двумя точками в $V$).

Функциональность NetworkX для двудольных графов находится в разделе [`nx.algorithms.bipartite`](https://networkx.org/documentation/stable/reference/algorithms/bipartite.html)
"""

from networkx.algorithms import bipartite

B = bipartite.random_graph(5, 7, 0.5)

nx.draw(B)

B.nodes(data=True)

"""
Явно определим позиции для визуализации двудольного графа:"""

pos = {}
cts = [0, 0]

for i, data in B.nodes(data=True):
    group = data['bipartite']
    pos[i] = np.array([group, cts[group]])
    cts[group] = cts[group] + 1

nx.draw(B, pos)

# set random weights
for i,j in B.edges():
    B[i][j]['weight'] = np.random.rand()

weights = [B[u][v]['weight'] for u,v in B.edges()]

nx.draw(B, pos, width=weights)

# compute maximum matching
match = bipartite.maximum_matching(B)
match

elist = [[k, v] for k, v in match.items()]

nx.draw(B, pos, width=weights)
nx.draw_networkx_edges(B, pos, elist, edge_color='r', width=1.0)
plt.show()

"""### Другие алгоритмы работы с графами

Существует множество применений графов и множество графовых алгоритмов [документацию по алгоритмам NetworkX](https://networkx.org/documentation/stable/reference/algorithms/index.html).

## Понимание графа

В научных вычислениях обычно получает граф из каких-то данных.
Часто такие графы называют «сложными сетями».  Одним из хороших источников данных является [Stanford Large Network Dataset Collection](http://snap.stanford.edu/data/index.html).

Графы могут храниться в различных форматах.
можно найти документацию по возможностям чтения/записи в NetworkX [здесь](https://networkx.org/documentation/stable/reference/readwrite/index.html).

В NetworkX также есть несколько встроенных примеров.
Одним из примеров является граф [Zachary Karate Club Graph](https://networkx.org/documentation/stable/auto_examples/graph/plot_karate_club.html), который отражает дружеские отношения между людьми в клубе каратэ.
Есть и другие примеры [графов социальных сетей](https://networkx.org/documentation/stable/reference/generators.html#module-networkx.generators.social).
"""

G = nx.karate_club_graph()
nx.draw_kamada_kawai(G)

"""Вот пример чтения и записи графа в виде списка edgelist:"""

B = bipartite.random_graph(5, 7, 0.5)
nx.write_edgelist(B, "bipartite.graph")

B2 = nx.read_edgelist("bipartite.graph")

list(B2)

