# -*- coding: utf-8 -*-
"""АТГ_сем 7,8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tzbleQHBS5iJnAusx5H3SfVGF0gjvXQp
"""

import torch
import torch.nn as nn
import torch.nn.functional as F
import networkx as nx
import numpy as np
import matplotlib.pyplot as plt
from torch_geometric.nn import GCNConv, global_mean_pool
from torch_geometric.data import Data, DataLoader
from torch_geometric.utils import from_networkx
import torch_geometric.transforms as T
import random

def create_seed_graphs():
    """Создает набор графов-затравок."""
    seeds = {}

    # Затравка 1: треугольник
    G1 = nx.Graph()
    G1.add_edges_from([(0, 1), (1, 2), (2, 0)])
    seeds['triangle'] = G1

    # Затравка 2: звезда
    G2 = nx.Graph()
    G2.add_edges_from([(0, i) for i in range(1, 4)])
    seeds['star'] = G2

    # Затравка 3: путь
    G3 = nx.Graph()
    G3.add_edges_from([(0, 1), (1, 2)])
    seeds['path'] = G3

    # Затравка 4: квадрат
    G4 = nx.Graph()
    G4.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])
    seeds['square'] = G4

    return seeds

# Определяем основные типы операций для связного графа
def add_vertex_with_edge(G, level, total_levels):
    """Добавить новую вершину с ребром к случайной существующей."""
    new_node = max(G.nodes) + 1 if len(G.nodes) > 0 else 0
    existing_node = random.choice(list(G.nodes))
    weight = 1 + level / total_levels  # Вес зависит от уровня
    G.add_node(new_node)
    G.add_edge(new_node, existing_node, weight=weight)

def add_edge(G, level, total_levels):
    """Добавить ребро между двумя случайными несмежными вершинами."""
    nodes = list(G.nodes)
    if len(nodes) > 1:
        u, v = random.sample(nodes, 2)
        if not G.has_edge(u, v):
            weight = 1 + level / total_levels  # Вес зависит от уровня
            G.add_edge(u, v, weight=weight)

def replace_vertex_with_seed(G, seeds, vertex, level, total_levels):
    """Заменить вершину затравкой, сохраняя связь с соседями."""
    if vertex not in G:
        return
    seed_key = random.choice(list(seeds.keys()))
    seed_graph = seeds[seed_key]

    # Сохраняем соседей текущей вершины
    neighbors = list(G.neighbors(vertex))
    G.remove_node(vertex)

    # Добавляем вершины и рёбра затравки
    mapping = {}
    for n in seed_graph.nodes:
        if n == 0:
            mapping[n] = vertex  # Сохраняем место удалённой вершины
            G.add_node(vertex)
        else:
            new_node = max(G.nodes) + 1
            G.add_node(new_node)
            mapping[n] = new_node

    for u, v in seed_graph.edges:
        weight = 1 + level / total_levels  # Вес зависит от уровня
        G.add_edge(mapping[u], mapping[v], weight=weight)

    # Восстанавливаем соседей к центральной вершине
    for neighbor in neighbors:
        weight = 1 + level / total_levels  # Вес зависит от уровня
        G.add_edge(vertex, neighbor, weight=weight)

# Основная функция эволюции графа
def evolve_graph(initial_seed, levels, num_operations):
    G = nx.Graph()
    G.add_nodes_from(initial_seed.nodes)
    G.add_edges_from(initial_seed.edges)

    seeds = create_seed_graphs()
    stages = []
    G_list = []  # Список для сохранения всех траекторий графа

    for level in range(levels):
        for _ in range(num_operations):
            operation = random.choice(
                ["add_vertex", "add_edge", "replace_vertex"]
            )
            if operation == "add_vertex":
                add_vertex_with_edge(G, level, levels)
            elif operation == "add_edge":
                add_edge(G, level, levels)
            elif operation == "replace_vertex" and len(G.nodes) > 0:
                vertex = random.choice(list(G.nodes))
                replace_vertex_with_seed(G, seeds, vertex, level, levels)

        # Сохраняем текущее состояние графа
        stages.append((list(G.nodes), list(G.edges(data=True))))
        G_list.append(G.copy())  # Сохраняем текущую копию графа

        # Проверка на минимальное количество вершин
        if len(G.nodes) >= 5000:
            break

    return G, stages, G_list

# Визуализация графа
def draw_graph(G):
    pos = nx.circular_layout(G)  # Раскладка графа
    edges = G.edges(data=True)

    # Отображаем рёбра с учётом их веса
#     weights = [edge[2].get('weight', 1) for edge in edges]
    nx.draw(G, pos, with_labels=False, node_size=10)
    plt.title("Эволюционный граф с весами рёбер")
    plt.show()

# Создание начального графа и эволюция
initial_seed = nx.complete_graph(200)  # Начальный граф - полный граф с 5 вершинами
levels = 10  # Увеличено число уровней
num_operations = 10  # Увеличено число операций на уровень
G, stages, G_list = evolve_graph(initial_seed, levels, num_operations)

# Подсчёт числа вершин
num_vertices = G.number_of_nodes()
print(f"Общее число вершин в графе: {num_vertices}")

# Визуализация финального графа
draw_graph(G)

# Проверка количества сохранённых траекторий
print(f"Сохранено траекторий графа: {len(G_list)}")

"""## Реализуем расчет спектральной меры подобия для графов:"""

import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
from scipy import linalg

def spectral_similarity(G1, G2):
    # Получаем матрицы смежности
    A1 = nx.adjacency_matrix(G1).todense()
    A2 = nx.adjacency_matrix(G2).todense()

    # SVD разложение
    U1, s1, Vh1 = linalg.svd(A1)
    U2, s2, Vh2 = linalg.svd(A2)

    # Определяем минимальный размер
    min_size = min(U1.shape[1], U2.shape[1])

    # Обрезаем матрицы до одинакового размера
    U1 = U1[:, :min_size]
    U2 = U2[:, :min_size]

    # Модуль элементов собственных векторов
    U1 = np.abs(U1)
    U2 = np.abs(U2)

    # Находим матрицу подобия для общих размерностей
    P = np.dot(U1, U2.T)

    # Бинаризация матрицы подобия
    P_binary = np.zeros_like(P)
    rows, cols = P.shape
    for i in range(cols):
        if i < rows:
            max_idx = np.argmax(P[:, i])
            P_binary[max_idx, i] = 1

    # Подсчет подобных вершин
    similar_vertices = np.sum(P_binary)

    return similar_vertices, P_binary

def calculate_similarity_metrics(G_list):
    n = len(G_list)
    similarities = []

    for i in range(n-1):
        G1 = G_list[i]
        G2 = G_list[i+1]

        similar_vertices, _ = spectral_similarity(G1, G2)
        total_vertices = max(G1.number_of_nodes(), G2.number_of_nodes())
        similarity_percentage = (similar_vertices / total_vertices) * 100

        print(f"Step {i+1}: Vertices in G1={G1.number_of_nodes()}, G2={G2.number_of_nodes()}, "
              f"Similar={similar_vertices}, Percentage={similarity_percentage:.2f}%")

        similarities.append({
            'step': i+1,
            'similar_vertices': similar_vertices,
            'total_vertices': total_vertices,
            'percentage': similarity_percentage,
            'vertices_G1': G1.number_of_nodes(),
            'vertices_G2': G2.number_of_nodes()
        })

    return similarities

def plot_similarity_evolution(similarities):
    plt.figure(figsize=(12, 8))

    # График процента подобия
    plt.subplot(2, 1, 1)
    steps = [s['step'] for s in similarities]
    percentages = [s['percentage'] for s in similarities]
    plt.plot(steps, percentages, 'b-', marker='o')
    plt.title('Эволюция меры подобия графов')
    plt.xlabel('Шаг траектории')
    plt.ylabel('Процент подобных вершин')
    plt.grid(True)

    # График количества вершин
    plt.subplot(2, 1, 2)
    vertices_G1 = [s['vertices_G1'] for s in similarities]
    vertices_G2 = [s['vertices_G2'] for s in similarities]
    plt.plot(steps, vertices_G1, 'g-', marker='s', label='Граф G1')
    plt.plot(steps, vertices_G2, 'r-', marker='o', label='Граф G2')
    plt.title('Изменение количества вершин')
    plt.xlabel('Шаг траектории')
    plt.ylabel('Количество вершин')
    plt.legend()
    plt.grid(True)

    plt.tight_layout()
    plt.show()

# Модифицируем графы (удаление/добавление 5-10% ребер)
def modify_graphs(G_list, modification_percentage=0.07):
    modified_graphs = []

    for G in G_list:
        G_mod = G.copy()
        edges = list(G_mod.edges())
        n_edges = len(edges)
        n_modifications = int(n_edges * modification_percentage)

        if n_edges > 0:  # Проверка на наличие рёбер
            # Случайное удаление рёбер
            edges_to_remove = np.random.choice(range(n_edges),
                                             min(n_modifications, n_edges),
                                             replace=False)
            for idx in edges_to_remove:
                G_mod.remove_edge(*edges[idx])

        # Случайное добавление рёбер
        nodes = list(G_mod.nodes())
        if len(nodes) > 1:  # Проверка на наличие достаточного количества вершин
            for _ in range(n_modifications):
                u, v = np.random.choice(nodes, 2, replace=False)
                if not G_mod.has_edge(u, v):
                    G_mod.add_edge(u, v)

        modified_graphs.append(G_mod)

    return modified_graphs

# Выполняем анализ для исходных графов
similarities = calculate_similarity_metrics(G_list)
plot_similarity_evolution(similarities)

# Модифицируем графы и повторяем анализ
modified_G_list = modify_graphs(G_list)
modified_similarities = calculate_similarity_metrics(modified_G_list)
plot_similarity_evolution(modified_similarities)

