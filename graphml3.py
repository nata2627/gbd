# -*- coding: utf-8 -*-
"""GraphML3_ГордееваНГ.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1m299OawN-oje_p18-puJI4-Sn0hBB8mi

# Graph SVM

## Init
"""

# Commented out IPython magic to ensure Python compatibility.
# dateset & lib
!gdown 13eNOIdjMm8uNAcRDMhDDd2-pP5uUXQZ9 --folder
!gdown 11MwbxLGm6rwzrhgtb352sj9rY-frWLM0 --folder
# Load libraries
import numpy as np
import scipy.io
# %matplotlib inline
#%matplotlib notebook
from matplotlib import pyplot
import matplotlib.pyplot as plt
from IPython.display import display, clear_output
plt.rcParams.update({'figure.max_open_warning': 0})
import time
import sys; sys.path.insert(0, 'lib/')
from lib.utils import compute_purity
from lib.utils import compute_SVM
from lib.utils import construct_knn_graph
from lib.utils import graph_laplacian
import warnings; warnings.filterwarnings("ignore")
import sklearn.metrics.pairwise

"""## Синтетические данные"""

# Dataset
mat = scipy.io.loadmat('datasets/data_twomoons_graphSVM.mat')
Xtrain = mat['Xtrain']
Cgt_train = mat['Cgt_train'] - 1; Cgt_train = Cgt_train.squeeze()
l_train = mat['l'].squeeze()
nb_labeled_data_per_class = mat['nb_labeled_data_per_class'].squeeze()
n = Xtrain.shape[0]
d = Xtrain.shape[1]
nc = len(np.unique(Cgt_train))
print(n,d,nc)
Xtest = mat['Xtest']
Cgt_test = mat['Cgt_test'] - 1; Cgt_test = Cgt_test.squeeze()
print('l_train:',l_train)
print('number of labeled data per class:',nb_labeled_data_per_class)
print('number of unlabeled data:',n-2*nb_labeled_data_per_class)

"""Обратим внимание, что в обучающей выборке находится лишь по одной размеченной метке для каждого класса:

![image.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAr4AAAGaCAIAAABmMNefAAAgAElEQVR4Ae2dL7DettKHAwMLyxz4wcLAzJyZOxcWXlhYdKZhZYEXFvZMSWFhYUBm3sLCwsLMHBJYGOjvrv7Ya79/pJU2OXb8ZDo9fm1Z3n28ln6SbOnZyD8IQAACEIAABCBQTeBZdUoSQgACEIAABCAAgRHpQBBAAAIQgAAEIGAggHQwwCIpBCAAAQhAAAJIB2IAAhCAAAQgAAEDAaSDARZJIQABCEAAAhA4unQ4vR7yv/sT4QABCEAAAhCAQInANelwus816t3DYymTT3T88Zd/DcO/fvmklxfp8NqiGd7/cudHxlO4eBoWyEc3+/m/m0JpuH/XFyqePo7At90M4Nt4jSORbyNGsWPjNXo+kmb416RD9EGys0gHERy91cNMLzjTX3XNGV7YMkoH5WC4bT3OPj7cTcJIzOjy1NMwxSTcApO0WjEWSne/vA97pSTN26tkVT89fQR+FfI5EfBnFlVbRH4VpjkRxc7MomrL85FsgL9l6VDFrzORQlbOSdc34xiare31vbrx4xj1Y7MQ8TRMF3ljbDm11/dLvF1CxNPHEfjlaNcpgK9p1GwT+TWU5jQUOzOLqi3PR7IJvpd0kLJ4/S+3Vk+vpetCXA3/Ft0Yqk9PDxzIgxf/LetmyeT1acpKnxJ4BzOWp9y+D8sn/HbaZR+M4B6GofUNCXF8Pjf6uyBz25bFUU/DlhEZKvv2nqRlDR3vteXuKC89fQw9ycBXdAubwC8AOjtM5J8hubmDYucmnvODno9kG3wv6RB9Wz4w2d+kA2KdsRA4p/ssLy42u5cuSXayZ8hvJ4TKe9lS/+TSIV4umHF/WviSva38++4+j1CIzXcPjxYRs7qGhJGXYeJavCkJ7zJGV1cu/Dzd5xEK8e5fvzwuBVPh7MVhTx9FOiQFA/wF5Ss/gH8FzNXdRP5VNBcPUOxcxHJ9p+cj2Qb/c0mHua15WV6M44UqSlyaTxSMyz0XTrnO+vIRS4Ud75b8X1Wuc+P18gWu7Y21l1SlaTgg9s1cS35zv6dhMYzk/6lTJGZ+8/pXD8YCNFXPkmqus6+ec+WAp4/JDOBfYX22G/hnSAo7iPwCoNVhip0VkNJPz0eyDf7nkg5T78ISSeqQSIMT61cyxaWNSQcZopg+E2hvQ+e3r2fvJBR6Biy8DAuiIWsjuVnXpN7yRl7+JedO2uhM+V0+58pe4ePlYxiw0O+lAv8K9bQb+Lf5nB8l8s+Z3NpDsXOLzoVjno9kG/ynlA7B4qnVfqH4lgRz5Sr8lnsunHIB8s1dll6H1dXDzyuS6OY148FVlTz3cFacu06yxNJn2GoURn5O92h93eLvFd6OnhXgF2GvEwB/TeT2byL/Np+zoxQ7Z0hu7/iiynxf6RCk0FltuirCJrqyPysDicIw5D8dPRMKcmQZrOfSIYj9nKfO6tr2Ndsupw/D/6lvIGzPPRCXT7i1Vy6da2WN4tY51455GhZuYmJ4+YZes+LCfumYyf00aoDgQsriLk8f46QOSRIBv8g+vopE5JdBTSmI/AlF1QbFThWmOZFnedgC/4p0CHGfhxHC3zNBMPugt4I/6cR8yvXqOXbrpfxVk1TtT3mlUv6JpUP+ijIa1aMbIrOgHkJmFrmjec/biny3YSGSopP5Js4Xsm7NsdT+kWe6pqePakoo4NfcU+DXUNJpiHxNo7xNsVNmtEjh+Uia4V+RDgsDv+Qf12XNl+w1vkEAAhCAAASaCSAd9CuBzRg5EQIQgAAEIHAUAibpcD6OkIcTpo8O9sZtHjLIrx3szQPshQAEIAABCHxWAibp8Fkt42IQgAAEIAABCGyQANJhgzcFkyAAAQhAAALbJYB02O69wTIIQAACEIDABgkgHTZ4UzAJAhCAAAQgsF0CSIft3hssgwAEIAABCGyQANJhgzcFkyAAAQhAAALbJeAqHdTkVq0rOU2k1ORW/ZP9zdO65UmRp+tYNzx9VBMa9n8a6mkY8I1hAXwjMM+PooEP/HMCWy3zzy3d6R5H6SCzPqQpkMPD3DMdsprkMVRjPdMhizF5CmSJp7zdcsc8fdSTaou/XQrJ0zDgG0MD+DZgRL6Nl169trtoBf4TwjdeetPJ3aSDjkhZqrmnLtSV/RjXp26v71VFKOtnydrNrULE00ddHOSlMZrFlqdhwDc+sMA3AlNKi8ivYOcZYBQ7FcB1Elf4OuPdb3tJB6mS50GKII2nZSGtkJZ3K3Wet1ary3Iq9mI1tu89fRzFknkxa9E3ZwuHVnPzNAz41dhjQuAbgRH5NmCeAUaxY2Mfmppe9Zrx0ltP7ikdYu0udc9wf1o1Xi0cJIfYMRAkyP275cNjyWoUlZ16LFJHyLLksmQmZnj5KM9wUjAibu4eHpe9Ixa7Qnx7GQZ8E/rYjwV8AzQi3wArdZR6BRjFjo29a9FqvPTWk/tKB6lcVa0/t6pNGGLtlSSInDnX2aZ8QuIoHVL1LHvmksuaWTTDx8dkhuiYWdnM8tZmmqdhwLexT8HpExXAB/4ZAc+nm2LnDO/tHa7wb19qb0c9pcMwvSaZXlDokA5DliACdDnoYEMs507Vs8iQh7vc3LdllN6TcPJRnuFBvxopMdojHYBvuJ3AN8DKbwgR+QZoFDsGWKlY/uLLfBuSraf2kg7rKjm2nxq9Xw12yM9GFZJe2FTvRZ5eN9fQrj6u9dA8sNIAbaWHgF9iuBKjwC8A8wwwIr8Ae30Y+Gsipd+rwd/NlPklu3d13E06jOG9hNRuTu8oNJMI3b/pVYCwrep+c6ahiRkHC0Nbv/1jDVcf46QOSRKl9zDMvuUTgJ9JVP4V4FmPAr8MzTPAiPwy70UK4C9wVPzYaplfYfpukvhJh/ydlfTD677NRhRBMcS8enRDvHrsoJbcOnRDzCo8xtGuJEcaHZTTQgUWMmv86ENd29Mw4CuwNZvAr6Gk0hD5CkbFpmeAUexUANdJXOHrjHe97Soddk0C4yEAAQhAAAIQqCCAdKiARBIIQAACEIAABDIBpEMmwV8IQAACEIAABCoIIB0qIJEEAhCAAAQgAIFMAOmQSfAXAhCAAAQgAIEKAkiHCkgkgQAEIAABCEAgE0A6ZBL8hQAEIAABCECgggDSoQISSSAAAQhAAAIQyASQDpkEfyEAAQhAAAIQqCDgKh3UrFutKzlNJqsJDftnWpxnk0yrZk+XMW94+qimdcuTIpvtmU7wNAz4E9a6DeDXcZpSzbNJEvkTlBsbngFGsXMD9KVDrvAvXWCX+xylg1pSKLDumadZSpY0/3SoxnrmohZj8vzToiHydsv98vRRr2oj/nYpJE/DgG8MDeDbgBH5Nl56wbDuohX4TwjfeOlNJ3eTDjoi0+oMzXWhruzT+t3t9b2qCPPywa1CxNNHXRzk5T+axZanYcA3PrDANwJTSovIr2DnGWAUOxXAdRJX+Drj3W97SQfpG5gHKYI0nlYmtEJa3q3Ued5arS7LqThy0ahpPH0Ma3jOK4mLvhkUQBsyT8OAb2M/At8ITJ5BIr8emmeAUezUcw8pXeEbr73x5J7SIdbuUvcM96dV49WCQXKIHQNBgty/W94/S1ajqOzUY5EGBZYllyUzMcPLR3mGk4IRcXP38LjsHbHYFWovL8OAb0I/At/Ii8g3AqPYMQLbbJlv9WPb6X2lg0S5qvXntoUJQqy9kgSRM+eHx5RPSBylQ6qeZc9cZ1szi2b4+JjMUO9enF539TpEgQX8qpsaYwD4VbCmB5DIr+WVWywUO7XEDlHm18LYRzpP6TAM6vuF9sb9GERDliCCcTnoYAMr5+pXIyXzjgELLx9FOgz61Ugpl+cRH5uPoUwHfj004NezkpSeAUbk29gD38gr1hdbLPPNjmz6BC/pEOp7VSVHFdno+mqwQ342dmCkFzbVe5EdjXtXH9d6aB5YaYC20kPALzFciVHgF4B5BhiRX4C9Pgz8NZHS79Xg72bK/JLduzruJh3G8F5CajendxSaSYRWThIiYVvV/eZMQxMzvWUp2+0fa7j6GL+uTpIovYdh9i2fAPxMovKvAM96FPhlaJ4BRuSXeS9SAH+Bo+LHVsv8CtN3k8RPOuTvrKQfXneeN6JIfaSSV49uiFePHdSSV4duiFmFxzi4qEZnGn1Uc7OoDpvGzDwNA77xJgDfCCxIt/AYEfk16DwDjGKnhrhK4wpf5bvvTVfpsG8UWA8BCEAAAhCAQJkA0qHMiBQQgAAEIAABCEwEkA4TCjYgAAEIQAACECgTQDqUGZECAhCAAAQgAIGJANJhQsEGBCAAAQhAAAJlAkiHMiNSQAACEIAABCAwEUA6TCjYgAAEIAABCECgTADpUGZECghAAAIQgAAEJgJIhwkFGxCAAAQgAAEIlAm4Sgc161brSk6TxWpCw/755ubZJLungPT0UU3rlidFnvw3b3gaBnwjfuAbgc2zSRL5Neg8A4xip4a4SuMKX+W7701H6aCWFAqs07IRTXykZEnzT4dqrGcuajEmzz/duYaFXrmn20e9qk3vMgquhgHfGLNEvg0YkW/j5fp0A/8J4RsvvenkbtJBR2Rar7K5t0BX9uMYVunNdb8dpqoI8/LBrULE00ddHOTlP5rFlqdhwDfGGPCNwJTSIvIr2HkGGMVOBXCdxBW+znj3217SQfoG5kGK0CKfVia0QlrerdR53lqtLsupOHLRqGk8fQx6aF5JXPTNoADakHkaBnwb+xH4RmDyDBL59dA8A4xip557SOkK33jtjSf3lA6xdpe6Z7g/rRqvFgySQ+wYCBLk/t3y/lmyGkVlpx6LNCiwLLksmYkZXj7KM5wUjIibu4fHZe+Ixa5Qe3kZBnwT+hH4Rl5EvhEYxY4R2GbLfKsf207vKx0kylWtP7ctTBBi7ZUkiJw5PzymfELiKB1S9Sx75jrbmlk0w8fHZIZ69+L0uqvXIQos4Ffd1BgDwK+CNT2ARH4tr9xiodipJXaIMr8Wxj7SeUqHYVDfL7Q37scgGrIEEYzLQQcbWDl3yB0PUgo+3OXmvi2jqGC8fBTpMAzKEimX5xEfm2mhTAd+PTTg17OSlJ4BRuTb2APfyCvWF1ss882ObPoEL+mwrpKjimx0fTXYIT8bOzDSC5vqvciOxr2rj2s9NA+sNEBb6SHglxiuxCjwC8A8A4zIL8BeHwb+mkjp92rwdzNlfsnuXR13kw5jeC8htZvTOwrNJEIrJ70KELZV3W/ONDQx01uWst3+sYarj/Hr6iSJ0nsYZt/yCcDPJCr/CvCsR4FfhuYZYER+mfciBfAXOCp+bLXMrzB9N0n8pEP+zkr64XXneSOK1EcqefXohnj12EEteXXohphVeIyDi2p0ptFHNTdL40cf6sKehgFfga3ZBH4NJZUmSLfwGBH5CsvVTc8Ao9i5ivnyAVf4ly+xw72u0mGH/mMyBCAAAQhAAAImAkgHEy4SQwACEIAABI5OAOlw9AjAfwhAAAIQgICJANLBhIvEEIAABCAAgaMTQDocPQLwHwIQgAAEIGAigHQw4SIxBCAAAQhA4OgEkA5HjwD8hwAEIAABCJgIIB1MuEgMAQhAAAIQODoBpMPRIwD/IQABCEAAAiYCrtJBzbrVupLTZLya0LB/vrl5NsnuKSA9fVTTuuVJkSf/zRuehgHfiB/4RmDzbJJEfg06zwCj2KkhrtK4wlf57nvTUTqoJYUC67RsRBMfKVnS/NOhGuuZi1qMyfNPd65hoVfu6fZRr2rTu4yCq2HAN8YskW8DRuTbeLk+3cB/QvjGS286uZt00BGZ1qts7i3Qlf04hlV6c91vh6kqwrx8cKsQ8fRRFwd5+Y9mseVpGPCNMQZ8IzCltIj8CnaeAUaxUwFcJ3GFrzPe/baXdJC+gXmQIrTIp5UJrZCWdyt1nrdWq8tyKo5cNGoaTx+DHppXEhd9MyiANmSehgHfxn4EvhGYPINEfj00zwCj2KnnHlK6wjdee+PJPaVDrN2l7hnuT6vGqwWD5BA7BoIEuX+3vH+WrEZR2anHIg0KLEsuS2ZihpeP8gwnBSPi5u7hcdk7YrEr1F5ehgHfhH4EvpEXkW8ERrFjBLbZMt/qx7bT+0oHiXJV689tCxOEWHslCSJnzg+PKZ+QOEqHVD3LnrnOtmYWzfDxMZmh3r04ve7qdYgCC/hVNzXGAPCrYE0PIJFfyyu3WCh2aokdosyvhbGPdJ7SYRjU9wvtjfsxiIYsQQTjctDBBlbOHXLHg5SCD3e5uW/LKCoYLx9FOgyDskTK5XnEx2ZaKNOBXw8N+PWsJKVngBH5NvbAN/KK9cUWy3yzI5s+wUs6rKvkqCIbXV8NdsjPxg6M9MKmei+yo3Hv6uNaD80DKw3QVnoI+CWGKzEK/AIwzwAj8guw14eBvyZS+r0a/N1MmV+ye1fH3aTDGN5LSO3m9I5CM4nQykmvAoRtVfebMw1NzPSWpWy3f6zh6mP8ujpJovQehtm3fALwM4nKvwI861Hgl6F5BhiRX+a9SAH8BY6KH1st8ytM300SP+mQv7OSfnjded6IIvWRSl49uiFePXZQS14duiFmFR7j4KIanWn0Uc3N0vjRh7qwp2HAV2BrNoFfQ0mlCdItPEZEvsJyddMzwCh2rmK+fMAV/uVL7HCvq3TYof+YDAEIQAACEICAiQDSwYSLxBCAAAQgAIGjE0A6HD0C8B8CEIAABCBgIoB0MOEiMQQgAAEIQODoBJAOR48A/IcABCAAAQiYCCAdTLhIDAEIQAACEDg6AaTD0SMA/yEAAQhAAAImAkgHEy4SQwACEIAABI5OAOlw9AjAfwhAAAIQgICJgKt0ULNuta7kNBmvJjTsn29unk2yewpITx/VtG55UuTJf/OGp2HAN+IHvhHYPJskkV+DzjPAKHZqiKs0rvBVvvvedJQOakmhwDotG9HER0qWNP90qMZ65qIWY/L8051rWOiVe7p91Kva9C6j4GoY8I0xS+TbgBH5Nl6uTzfwnxC+8dKbTu4mHXREpvUqm3sLdGU/jmGV3lz322GqijAvH9wqRDx91MVBXv6jWWx5GgZ8Y4wB3whMKS0iv4KdZ4BR7FQA10lc4euMd7/tJR2kb2AepAgt8mllQiuk5d1Kneet1eqynIojF42axtPHoIfmlcRF3wwKoA2Zp2HAt7EfgW8EJs8gkV8PzTPAKHbquYeUrvCN1954ck/pEGt3qXuG+9Oq8WrBIDnEjoEgQe7fLe+fJatRVHbqsUiDAsuSy5KZmOHlozzDScGIuLl7eFz2jljsCrWXl2HAN6EfgW/kReQbgVHsGIFttsy3+rHt9L7SQaJc1fpz28IEIdZeSYLImfPDY8onJI7SIVXPsmeus62ZRTN8fExmqHcvTq+7eh2iwAJ+1U2NMQD8KljTA0jk1/LKLRaKnVpihyjza2HsI52ndBgG9f1Ce+N+DKIhSxDBuBx0sIGVc4fc8SCl4MNdbu7bMooKxstHkQ7DoCyRcnke8bGZFsp04NdDA349K0npGWBEvo098I28Yn2xxTLf7MimT/CSDusqOarIRtdXgx3ys7EDI72wqd6L7Gjcu/q41kPzwEoDtJUeAn6J4UqMAr8AzDPAiPwC7PVh4K+JlH6vBn83U+aX7N7VcTfpMIb3ElK7Ob2j0EwitHLSqwBhW9X95kxDEzO9ZSnb7R9ruPoYv65Okii9h2H2LZ8A/Eyi8q8Az3oU+GVongFG5Jd5L1IAf4Gj4sdWy/wK03eTxE865O+spB9ed543okh9pJJXj26IV48d1JJXh26IWYXHOLioRmcafVRzszR+9KEu7GkY8BXYmk3g11BSaYJ0C48Rka+wXN30DDCKnauYLx9whX/5Ejvc6yoddug/JkMAAhCAAAQgYCKAdDDhIjEEIAABCEDg6ASQDkePAPyHAAQgAAEImAggHUy4SAwBCEAAAhA4OgGkw9EjAP8hAAEIQAACJgJIBxMuEkMAAhCAAASOTgDpcPQIwH8IQAACEICAiQDSwYSLxBCAAAQgAIGjE0A6HD0C8B8CEIAABCBgIuAqHdSsW60rOU3GqwkN++ebm2eT7J4C0tNHNa1bnhR58t+84WkY8I34gW8ENs8mSeTXoPMMMIqdGuIqjSt8le++Nx2lg1pSKLBOy0Y08ZGSJc0/HaqxnrmoxZg8/3TnGhZ65Z5uH/WqNr3LKLgaBnxjzBL5NmBEvo2X69MN/CeEb7z0ppO7SQcdkWm9yubeAl3Zj2NYpTfX/XaYqiLMywe3ChFPH3VxkJf/aBZbnoYB3xhjwDcCU0qLyK9g5xlgFDsVwHUSV/g6491ve0kH6RuYBylCi3xamdAKaXm3Uud5a7W6LKfiyEWjpvH0MeiheSVx0TeDAmhD5mkY8G3sR+AbgckzSOTXQ/MMMIqdeu4hpSt847U3ntxTOsTaXeqe4f60arxaMEgOsWMgSJD7d8v7Z8lqFJWdeizSoMCy5LJkJmZ4+SjPcFIwIm7uHh6XvSMWu0Lt5WUY8E3oR+AbeRH5RmAUO0Zgmy3zrX5sO72vdJAoV7X+3LYwQYi1V5Igcub88JjyCYmjdEjVs+yZ62xrZtEMHx+TGerdi9Prrl6HKLCAX3VTYwwAvwrW9AAS+bW8couFYqeW2CHK/FoY+0jnKR2GQX2/0N64H4NoyBJEMC4HHWxg5dwhdzxIKfhwl5v7toyigvHyUaTDMChLpFyeR3xspoUyHfj10IBfz0pSegYYkW9jD3wjr1hfbLHMNzuy6RO8pMO6So4qstH11WCH/GzswEgvbKr3Ijsa964+rvXQPLDSAG2lh4BfYrgSo8AvAPMMMCK/AHt9GPhrIqXfq8HfzZT5Jbt3ddxNOozhvYTUbk7vKDSTCK2c9CpA2FZ1vznT0MRMb1nKdvvHGq4+xq+rkyRK72GYfcsnAD+TqPwrwLMeBX4ZmmeAEfll3osUwF/gqPix1TK/wvTdJPGTDvk7K+mH153njShSH6nk1aMb4tVjB7Xk1aEbYlbhMQ4uqtGZRh/V3CyNH32oC3saBnwFtmYT+DWUVJog3cJjROQrLFc3PQOMYucq5ssHXOFfvsQO97pKhx36j8kQgAAEIAABCJgIIB1MuEgMAQhAAAIQODoBpMPRIwD/IQABCEAAAiYCSAcTLtfEf/45/vFH1X9//ul6YTKDAAQgAAEItBNAOrSzM5z555/jTz+NP/44vno1vngxPntm/u+nnwyXIykEIAABCEDgkxFAOnwytDHjv/8e//3vtVD46ivREJX//d//yelv3nxiQ8keAhCAAAQgUEUA6VCFqTHR33+Pz59Lxf/ypdT9b9/K8IT136+/Sg7/+Y/1PNJDAAIQgAAEPgUBpMOnoJrzjP0NnR0GHz6MX30l6uHXX3O+/IUABCAAAQg8GQGkwydD//at1PfffONwgbdvU+8Fbzw40CQLCEAAAhDoIuAqHdSsW60rOU3OqAkN++ebm2eT7J4Cst7H//5XpMPPP08uXdqIblbMcTmph++/v5TPGCfJjtNcAv8youXeeULDPCP18rjlV31UlHPdf+SXfVQTGgK/Apfr0w38GuIqjefTrbLd+aajdFBLCgXWadmIJkBSrKf5p0NJ2jMXtRiT6+bONSz0yj1FH7/7TqTDjZcbomEP1ctq/PXX+PXXkucPP5xBBf4Zkps79JJCvWtYmKLiplXL1dp2G/klH4FfIrQ67vl0A38Ft/TTE37pWns67iYddESmErC5t0BX9uMYVunNdb+drVIhefngViFi8/HlS6nm//77ismPv/wrrH1lUjPv36eRiw8fdLY2w/SZ59tfBvxzvxZ7VHGQ115pVrrAX6At/wB+mZFO4RlgWuYS+ZrylW1X+Feusc/dXtJBWkhzP3lokU8rE1rJLO9W6r9tLdmX5VQcuWjUNEYfX70S6fD+fcF9k3QYx/H77yXb339X2RoNU2eeb34h8M8d03uE+byMexy5mKNXpyxvA7/MaJEC+AscxR+eARaaYUR+kfmUwBX+lOsXseEpHWLtLnXPcH9aNV4tsCSH2DEQJMj9u+X9s2Q1ispOPRapX3pZclkyEzMMPn4i6fDbb2djFkbDbvr8hcC/6aMUoEk+irK8e3hcdk3dPnl1FPgrIKWfwC8RWh73DDAif8m2+MsVfvFqu0rgKx0EtKr1Z3lrYhJrryRB5Mz5/pnyCYmjdEg1hOyZSy5rZtGMah+jdCjOIW3tdfjrL5EOr14p642GqTPPN78Q+OeO6T0xBhT502vVZ6ZTlreBX2a0SAH8BY7iD88AS6UfkV+knhK4wq+96D7SeUqHYVDfL7Q37scgGrIEEYzLQQcbWDl3yB0PIkMe7nKL05ZRVDAGH6N0uPGaZLy+eoyrDPr4UaTDixcqscS3wTB15vnmFwL/3DG9R5gPKgwEYM+ABfA13cI28AuAVoc9n26RDkT+CvCtn67wb11of8e8pMO6So6N10Yeq8EO+dnYgbF8ZV3M6WhfGn389lup492lwzhKtv+bmlr9W+kh4Cs2FzdXYnQe1bqY+vZO4N/mc3YU+GdIbu7wDLB1M4zIv4n+rKnZVbQWLrWzw4saqMv28F5CarqldxSa8wtaL41Gh+3WbyLEgiC001uWst3+sUb8urrWx/hxZnEKyAaT4ieami7wNY2K7fBqZNKj6SWYirMuJwH+ZS5X9wL/KpqLBzwDLE7qQORfBH1ppyv8SxfY6z4/6ZA/9ZEOMT1y0Ugm9RRJXj26IV49dtNJXh26IWYVIim4qEZnLvr45o30DVyf/zEUoDGn9P/ar0jOpQPwL96Cmztn/o1f3Kjc66NCnXRlc/+Rf8UxvRv4mkZ52zPA1JRQRH4Z/WK2vdoiuibbnadxlQ47Z+Fs/oVPITyuEN91eP7cIy/ygAAEIAABCJgJIB3MyGpP+Ptv6XVYfApRe+qtdD/9JNl+++2tNByDAAQgAAEIfDICSIdPhnYcZcXL58/H5cyP7dd7/16W3n72TO0e7bMAACAASURBVPIsfvPZfhnOhAAEIAABCNwigHS4Raf32A8/SE3/73+PHz/2ZvXzz2kK6q+/Ln+10XsxzocABCAAAQhcJYB0uIrG4cDHj7Lo9s2XJS9f5eNH0Qf/e8XyzRv5L37n+b/3G968Gf/55/Ip7IUABCAAAQh8FgJIh0+M+c8/RTp8/fX422+iBq5V/H/8kbTC998ntREnb5j+/9VX49u3n9hWsocABCAAAQiUCSAdyox6U8QXFCYRULPx4sX43Xepy+HNG+l+8HphotcZzocABCAAgaMTQDp8+gj4+HH89VcZdHj1aowrca/Uw4sXcihqhd9+QyV8+lvCFSAAAQhAoJ0A0qGdHWdCAAIQgAAEDkgA6XDAm47LEIAABCAAgXYCrtJBzZbaug7h5Imajrd/ttR5IurS7NHT9a9tePqoZoTtWN8rWeppGPCv3f4r+4F/Bcy13fNE1ET+NUZ6v2eAUexoshXbrvArrrePJI7SQS2IF1j3TPctJUtauiJUYz3LWIgxeemKhrWmFvfR00e9IJ7426WQPA0D/uKel38Av8xIpyDyNY2Kbc8AA34FcJ3EE77Od+/bbtJBR2Ra6rq5LtSVfVr6Mtf9dt6qIhzHsUuIePq4Wv22T2x5GgZ8Y4wB3whMlcV52bbmZgbwgX9OYKtl/rmlO97jJR2kSp4HKUJFOLR2RS6Lg9R53lq4LMupOHLRqGk8fQxLgaelb5PSGhRAW0R5GgZ8G/sgRol8AzR5Bon8emCeTzfFTj33kNIVvvHaG0/uKR1i7S51z3B/WjVeLRgkhzhCkdriy/tnyWqUxn3qsUiDAsuSy5KZmOHlozzDScGIuLl7eFwqZYtdofbyMgz4JvSxHwv4BmhEvgFW6ij1CjCKHRt716LVeOmtJ/eVDlK5qlp/bluYMMTaK0kQOXOus035hMRROqTqWfbMJZc1s2iGj4/JDPXuxel1V6/D/Tsfw4BvDAvPqAA+8M8IeAYYxc4Z3ts7XOHfvtTejnpKh2FQ3y+0N+7HIBqyBBGgy0EHG2I5d8gdDyJDHu5yc9+WUXpPwslHeYYH/WqkxOjc720zTc4FvoEZ8A2w8htCRL4BGsWOAVYqlocvvcy3Idl6ai/psK6SY/up0fvVYIf8bOzASK8RqA80Ohr3rj6u9dA8sNIAbaWHgF9iuBKjwC8A8wwwIr8Ae30Y+Gsipd+rwd/NlPklu3d13E06jOG9hNRuTu8oNJMIzej0KkDYVnW/OdPQxIyDhaGt3/6xhquP8evqJInSexhm3/IJwM8kKv8K8KxHgV+G5hlgRH6Z9yIF8Bc4Kn5stcyvMH03SfykQ/7OSrrOdd9mI4rUCS959eiGePXYQS15deiGmFV4jIOLanSm0Uc1N0vjRx/qwp6GAV+BrdkEfg0llSZIt/AYEfkKy9VNzwCj2LmK+fIBV/iXL7HDva7SYYf+YzIEIAABCEAAAiYCSAcTLhJDAAIQgAAEjk4A6XD0CMB/CEAAAhCAgIkA0sGEi8QQgAAEIACBoxNAOhw9AvAfAhCAAAQgYCKAdDDhIjEEIAABCEDg6ASQDkePAPyHAAQgAAEImAggHUy4SAwBCEAAAhA4OgGkw9EjAP8hAAEIQAACJgKu0kHNutW6ktNkvJrQsH++uXk2ye4pID19VNO65UmRJ//NG56GAd+IH/hGYPNskkR+DTrPAKPYqSGu0rjCV/nue9NROqglhQLrtGxEEx8pWdL806Ea65mLWozJ80+LhsjbLYZ5+qhXteldRkEvKQT8ijsL/ApIOgmRr2lUbFPsVEDSSY5Q5mt/977tJh10WZzWq2zuLdBP3Th2rlmlIjIvH9wqRDx91JV9Xv6jWWx5GgZ84zMNfCMwpUKI/Ap2ngFGsVMBXCdxha8z3v22l3SQvoF5kCI0fKeVCa2QlncrdZ63VqvLciqOXDRqGk8fgx6aVxIXfTMogDZknoYB38Z+BL4RmDyDRH49NM8Ao9ip5x5SusI3XnvjyT2lQ6zdpe4Z7k+rxqsFg+QQOwaCBLl/t7x/lqxGUdlphCINCixLLktmYoaXj/IMJwUj4ubu4XHZO2KxK9ReXoYB34R+BL6RF5FvBEaxYwS22TLf6se20/tKB4lyVevPbQsThFh7JQkiZ84PjymfkDhKh1Q9y565zrZmFs3w8TGZod69OL3u6nWIAgv4VTc1xgDwq2BNDyCRX8srt1godmqJHaLMr4Wxj3Se0mEY1PcL7Y37MYiGLEEE43LQwQZWztWvRkrmHQMWXj6KdBgGZYmUy/OIj83HUKYDvx4a8OtZSUrPACPybeyBb+QV64stlvlmRzZ9gpd0CPW9qpKjimx0fTXYIT8bOzDSC5vqvciOxr2rj2s9NA+sNEBb6SHglxiuxCjwC8A8A4zIL8BeHwb+mkjp92rwdzNlfsnuXR13kw5jeC8htZvTOwrNJEIrJwmRsK3qfnOmoYmZ3rKU7Y6PMz19jF9XJ0mU3sMw+5ZP8DQM+Jlq5V/gV4LKySTac2OAyM9Urv/1DDCKneucLx5xhX/xCjvd6Scd8ndW0g+vO88bwaQ+UsmrRzfEq8cOasmrQzfErEIkBRfV6Eyjj2puFtVh05iZp2HAN94E4BuBBfUQHiMivwadZ4BR7NQQV2lc4at8973pKh32jQLrIQABCEAAAhAoE0A6lBmRAgIQgAAEIACBiQDSYULBBgQgAAEIQAACZQJIhzIjUkAAAhCAAAQgMBFAOkwo2IAABCAAAQhAoEwA6VBmRAoIQAACEIAABCYCSIcJBRsQgAAEIAABCJQJIB3KjEgBAQhAAAIQgMBEAOkwoWADAhCAAAQgAIEyAVfpoGbdal3JabJYTWjYP9/cPJtk9xSQnj6qad3yvLyT/+YNT8OAb8QPfCOweTZJIr8GnWeAUezUEFdpXOGrfPe96Sgd1JJCgXVaNqKJj5Qsaf7pUI31zEUtxuT5pzvXsNAr93T7qFe16Z3J39Uw4Btjlsi3ASPybbxcn27gPyF846U3ndxNOuiITOtVNvcW6Mp+HMMqvbnut8NUFWFePrhViHj6qIuDvPxHs9jyNAz4xhgDvhGYUlpEfgU7zwCj2KkArpO4wtcZ737bSzpI38A8SBFa5NPieFZIy7uVOs9bq9VlORVHLho1jaePQQ/NK4mLvhkUQBsyT8OAb2M/At8ITJ5BIr8emmeAUezUcw8pXeEbr73x5J7SIdbuUvcM96dV49WCQXKIHQNBgty/W94/S1ajqOzUY5EGBZYllyUzMcPLR3mGk4IRcXP38LjsHbHYFWovL8OAb0I/At/Ii8g3AqPYMQLbbJlv9WPb6X2lg0S5qvXntoUJQqy9kgSRM+eHx5RPSBylQ6qeZc9cZ1szi2b4+JjMUO9enF539TpEgQX8qpsaYwD4VbCmB5DIr+WVWywUO7XEDlHm18LYRzpP6TAM6vuF9sb9GERDliCCcTnoYAMr5w6540FKwYe73Ny3ZRQVjJePIh2GQVki5fI84mMzLZTpwK+HBvx6VpLSM8CIfBt74Bt5xfpii2W+2ZFNn+AlHdZVclSRja6vBjvkZ2MHRnphU70X2dG4d/VxrYfmgZUGaCs9BPwSw5UYBX4BmGeAEfkF2OvDwF8TKf1eDf5upswv2b2r427SYQzvJaR2c3pHoZlEaOWkVwHCtqr7zZmGJmZ6y1K22z/WcPUxfl2dJFF6D8PsWz4B+JlE5V8BnvUo8MvQPAOMyC/zXqQA/gJHxY+tlvkVpu8miZ90yN9ZST+87jxvRJH6SCWvHt0Qrx47qCWvDt0QswqPcXBRjc40+qjmZmn86ENd2NMw4CuwNZvAr6Gk0gTpFh4jIl9hubrpGWAUO1cxXz7gCv/yJXa411U67NB/TIYABCAAAQhAwEQA6WDCRWIIQAACEIDA0QkgHY4eAfgPAQh8bgIfPnzuK3I9CLgSQDq44iQzCEDgaAQ+fhz/+GN882Z89Wr85pvx2bP1fy9fyqH4348/jj/+KAm+/VbO+vjxaLTw98sggHT4Mu4jXkAAAk9B4O3b8cWLtVY4Vw/X9rx58xRGc00I9BJAOvQS5HwIQOCgBN68SaLh22/Hn3+WXoR//rmM4o8/5Ogff4y//Sb9E7Hj4dmz8e3by+nZC4FtE0A6bPv+YB0EILBNAlE3PH8ugqDhXzz95UvGLBrgccqTE0A6PPktwAAIQGBvBH74Qfobnj9v7zb4+FHefnj2bHz5cvz11735j71HJ4B0OHoE4D8EIGAj8P33UuV/9VVjf8N0sQ8fRDfE1yC++YbuhwkMG9sn4Cod1KxbrSs5TcTUhIb9883Ns0l2TwHp6aOa1i1Pijz5b97wNAz4RvzANwKbZ5PcXeT/979JN/z9d9FpWX5iKC1r9/vvSUDceGXSM8Aodor3bZnAFf4y6x3/cpQOakmhwDotG9EER0qWNP90qMZ65qIWY/L8051rWOiVe7p91Kva9C6j4GoY8I0xS+TbgO048j9+lEGK58/Hv/4q+SwF193DL7JqzsNjIfFff4kcefXqSjLPANsx/Ct0Luzeapl/wdTd7nKTDjoi03qVzb0F+saPY1ilN9f9dtCqIszLB7cKEU8fdWWfl/9oFluehgHfGGPANwJTFeHuIv/336WO/89/ii4/PtyFx1mcLUuHcZQvPJ8/v/iBhmeAUewU79wygSv8ZdY7/+UlHaLEzuI6tMinlQmtiJZ3K3Wet1ary3Iqjlw0ahpPH4MemlcSF31TWcRcoOlpGPAvAL61C/i36Fw4Js/gbiP/119FOtwYWVg7XC0dvvtOcv7993UGo2eAUeyc4b29wxX+7Uvt7aindIi1u9Q9w/1p1Xi1cJEcYsdAkCD375b3z5LVKCo79VikQYFlyWXJTMzw8lGe4aRgUuGy7B2x2BUKFy/DgG9CPwLfyGvfkf/ppMPPP4t0+OGHM5wUO2dICju2WuYXzN7ZYV/pIFGuav25bWGiEmuvJEHkzPnhMeUTEscwUtp/rrOtmUUzfHxMBah69+L0uq5j84LVnoYB/wLgW7uAf4vOhWPxAdxp5H866RBz/u67M2KeAUaxc4b39g5X+LcvtbejntJhGNT3C+2N+zGIhixBBOhy0MGGWM4dcseDyJCHu9zct2UUFYyXj/IMD4OyRGK0akz0gtVyrpdhwL8A+NYu4N+ic+HYriP/XDqkwVl5AHU5kx1XjZa86/Lfm9LB6+mm2LkM/+pez6f76kX2ecBLOqyr5Nh4bWSyGuyQn40dGOmFTfVeZEfj3tXHtR6aO9kaoK30EPBLDFdiFPgFYJ4BtuvI/+mnT/Wuw1XpQLFTCM7zw6vB382U+eeW7niPm3QYg/pO7eaw3fpiY/4OIr0KEHSfqvvNsEMrJxkj2+0fa7j6GL+uTpIovYdh9i2fAPxMovKvAM96FPhlaJ4BtufIj7NH//RTmVhKYex1+P77CzkD/wKUm7u2WubfNHpnB/2kQ/7OKvbcdeiGSDD1FEluPbohZhb7SC/3KBpvWHiMnXxUc7M0fvShjPc0DPgKbM0m8GsoqTRBuoXHaF+RH6VDzbzRc5kTS4tSORZntr6Ws2eAUeyoQKzZdIVfc8FdpHGVDrvwGCMhAAEItBGolw6m/N+/TzNNffhgOo/EEHgqAkiHpyLPdSEAgb0RiNLh55897f7tN5kP6tkzWYmbfxDYCQGkw05uFGZCAAJPTiDOvmCYEuqmxb//nkTDs2fjhc8yb57LQQg8KQGkw5Pi5+IQgMCOCLx9K90DL186rHIZOzDi0hVv3+6IAaZCYBxHpANhAAEIQKCawDffiHp4/lz6Cd68Gd++laW343///FOVy7RU5vPnl2aersqDRBB4WgJIh6flz9UhAIFdEXj/fvz2W1EPN/776itZBvPif9NZL15ULL+5KzIYeyQCSIcj3W18hQAEXAh8+CA9Df976eHNG+l+iCrh5ctbeiKKhq+/FuXh+6Kli0dkAgELAaSDhRZpIQABCNQQiNpiGsuIGx8/1pxKGghsnwDSYfv3CAshAAEIQAACGyLgKh3UrFutKzlNaNSEhv3zzamZ3XqnufT0UU3rlidFnvw3b3gaBnwjfuAbgc2zSRL5Neg8A4xip4a4SuMKX+W7701H6aCWFAqseyppKVnS/NOhGuuZi1qMyetWiIbI2y03ztNHvaRQ7zIKekkh4FfcWeBXQNJJiHxNo2KbYqcCkk5yhDJf+7v3bTfpoMvitF5lc2+BfurGMSwU217fq4jMC2u1ChFPH3Vln5f/aBZbnoYB3/hMA98ITKkQIr+CnWeAUexUANdJXOHrjHe/7SUdpG9gHqQIDd9pZUIrpOXdSp3nrdXqspyKIxeNmsbTx6CH5pXERd8MCqANmadhwLexH4FvBCbPIJFfD80zwCh26rmHlK7wjdfeeHJP6RBrd6l7hvvTqvFqwSA5xI6BIEHu3y3vnyWrUVR26rFIgwLLksuSmZjh5aM8w0nBiLi5e3hc9o5Y7Aq1l5dhwDehH4Fv5EXkG4FR7BiBbbbMt/qx7fS+0kGiXNX6c9vCBCHWXkmCyJnzw2PKJySO0iFVz7JnrrOtmUUzfHxMZqh3L06vu3odosACftVNjTEA/CpY0wNI5Nfyyi0Wip1aYoco82th7COdp3QYhtQoF9fbG/djEA1Zgkhey0EHG1g5V78aKZl3DFh4+Rj4DMoSKZfnER+bj6FMB349NAlO4Nfz8gwwIr+ee0gJfCOwUF9sscy3+rHt9F7SIdT3qkqOKrLR99Vgh/xs7MBIL2yq9yI7GveuPq710Dyw0gBtpYeAX2K4EqPALwDzDDAivwB7fRj4ayKl36vB382U+SW7d3XcTTqM4b2E1G5O7yg0kwhCOwmRsK3qfnOmoYmZ3rJUfdTmfPLb4E4+xq+rkyRK72G02BTOAb4RnQDPehT4ZXieAUbkl3kvUgB/gaPix1bL/ArTd5PETzrkmlW6gnXneSOK1E0nefXohnj12EEtebV/5Jn8CI9xcFGNzjT6qOZmUR02jZl5GgZ8400AvhFYkG7hMSLya9B5BhjFTg1xlcYVvsp335uu0mHfKLAeAhCAAAQgAIEyAaRDmREpIAABCEAAAhCYCCAdJhRsQAACEIAABCBQJoB0KDMiBQQgAAEIQAACEwGkw4SCDQhAAAIQgAAEygSQDmVGpIAABCAAAQhAYCKAdJhQsAEBCEAAAhCAQJkA0qHMiBQQgAAEIAABCEwEkA4TCjYgAAEIQAACECgTcJUOatat1pWcJovVhIb9883Ns0l2TwHp6aOa1i1Pijz5b97wNAz4RvzANwKbZ5Mk8mvQeQYYxU4NcZXGFb7Kd9+bjtJBLSkUWKdlI5r4SMmS5p8O1VjPXNRiTJ5/unMNC71yT7ePelWb3mUUXA0DvjFmiXwbMCLfxsv16Qb+E8I3XnrTyd2kg47ItF5lc2+BruzT+t257rfDVBXhOI5dQsTTR10c5OU/msWWp2HAN8YY8I3AlNIi8ivYeQYYxU4FcJ3EFb7OePfbXtJBquR5kCK0yKeVCa2QlncrdZ63VqvLciqOXDRqGk8fR7FkXklc9M2gANqQeRoGfBv7IEaJfAM0It8AK7V2vAKMYsfG3vXpNl5668k9pUOs3aXuGe5Pq8arhYPkEEcoggS5f7esGi1ZjaKyU49FGhRYllyWzMQMLx/lGU4KRsTN3cPjsnfEYleIby/DgG9CH/uxgG+ARuQbYCXp4BVgFDs29q5Fq/HSW0/uKx2kclW1/tyqNmGItVeSIHLmXGeb8gmJo3RI1bPsmUsua2bRDB8fkxmiY2ZlM7ctbKZ5GgZ8G/sUnD5RAXzgnxHwfLopds7w3t7hCv/2pfZ21FM6DIP6fqG9cT8G0ZAliABdDjrYEMu5U/UsMuThLjf3bRml9yScfJRneBiUJRKjPdIB+IbbCXwDrKTdvQKMyLexD9oU+BZoWy3zLT5sP62XdFhXybH91Oj/arBDfjZ2YKQXNtUHGqfXzTW0q49rPTQPrDRAW+kh4JcYrsQo8AvAPAOMyC/AXh8G/ppI6fdq8HczZX7J7l0dd5MOY3gvIbWb0zsKzSRC9296FSBsq7rfnGloYsbBwtDiaf9Yw9XH+HV1kkTpPQyzb/kE4GcSlX8FeNajwC9D8wwwIr/Me5EC+AscFT+2WuZXmL6bJH7SIX9nJf3wule/EUVQDDGvHt0Qrx47qCW3Dt0QswqPcbQryZFGB+W0UIGFzBo/+lDX9jQM+ApszSbwayipNES+glGx6RlgFDsVwHUSV/g6411vu0qHXZPAeAhAAAIQgAAEKgggHSogkQQCEIAABCAAgUwA6ZBJ8BcCEIAABCAAgQoCSIcKSCSBAAQgAAEIQCATQDpkEvyFAAQgAAEIQKCCANKhAhJJIAABCEAAAhDIBJAOmQR/IQABCEAAAhCoIIB0qIBEEghAAAIQgAAEMgGkQybBXwhAAAIQgAAEKgi4Sgc161brSk6TyWpCw/6ZFufZJNUCXdOlTBuePqpp3fKkyCZbFok9DQP+Am35B/DLjBYp5tkkifwFmCs/PAOMYucK5Gu7XeFfu8ju9jtKB7WkUGDdM0+zlCxp/ulQjfXMRS3G5PmnRUPk7ZZ75emjXtVG/O1SSJ6GAd8YGsC3ASPybbz0gmHdRSvwnxC+8dKbTu4mHXREptUZmutCXdmPY+eaVaoizMsHtwoRTx91cZCX/2gWW56GAd/4wALfCEwpLSK/gp1ngFHsVADXSVzh64x3v+0lHaRvYB6kCNJ4WpnQCml5t1LneWu1uiyn4shFo6bx9DHooXklcdE3gwJoQ+ZpGPBt7EfgG4HJM0jk10PzDDCKnXruIaUrfOO1N57cUzrE2l3qnuH+tGq8WjBIDrFjIEiQ+3fL+2fJahSVnUYo0qDAsuSyZCZmePkoz3BSMCJu7h4el70jFrtC7eVlGPBN6EfgG3kR+UZgFDtGYJst861+bDu9r3SQKFe1/ty2MEGItVeSIHLm/PCY8gmJo3RI1bPsmetsa2bRDB8fkxnq3YvT665ehyiwgF91U2MMAL8K1vQAEvm1vHKLhWKnltghyvxaGPtI5ykdhkF9v9DeuB+DaMgSRDAuBx1sYOVc/WqkZN4xYOHlo0iHQb8aKeXyPOJj8zGU6cCvhwb8elaS0jPAiHwbe+AbecX6YotlvtmRTZ/gJR1Cfa+q5KgiG11fDXbIz8YOjPTCpnovsqNx7+rjWg/NAysN0FZ6CPglhisxCvwCMM8AI/ILsNeHgb8mUvq9GvzdTJlfsntXx92kwxjeS0jt5vSOQjOJ0MpJQiRsq7rfnGloYqa3LGW74+NMTx/j19VJEqX3MMy+5RM8DQN+plr5F/iVoHIyifbcGCDyM5Xrfz0DjGLnOueLR1zhX7zCTnf6SYf8nZX0w+vO80YwqY9U8urRDfHqsYNa8urQDTGrEEnBRTU60+ijmptFddg0ZuZpGPCNNwH4RmBBPYTHiMivQecZYBQ7NcRVGlf4Kt99b7pKh32jwHoIQAACEIAABMoEkA5lRqSAAAQgAAEIQGAigHSYULABAQhAAAIQgECZANKhzIgUEIAABCAAAQhMBJAOEwo2IAABCEAAAhAoE0A6lBmRAgIQgAAEIACBiQDSYULBBgQgAAEIQAACZQJIhzIjUkAAAhCAAAQgMBFAOkwo2IAABCAAAQhAoEzAVTqoWbdaV3KaLFYTGvbPNzfPJtk9BaSnj2patzwv7+S/ecPTMOAb8QPfCGyeTZLIr0HnGWAUOzXEVRpX+CrffW86Sge1pFBgnZaNaOIjJUuafzpUYz1zUYsxef7pzjUs9Mo93T7qVW16Z/J3NQz4xpgl8m3AiHwbL9enG/hPCN946U0nd5MOOiLTepXNvQW6sh/HsEpvrvvtMFVFmJcPbhUinj7q4iAv/9EstjwNA74xxoBvBKaUFpFfwc4zwCh2KoDrJK7wdca73/aSDtI3MA9ShBb5tDieFdLybqXO89ZqdVlOxZGLRk3j6WPQQ/NK4qJvBgXQhszTMODb2I/ANwKTZ5DIr4fmGWAUO/XcQ0pX+MZrbzy5p3SItbvUPcP9adV4tWCQHGLHQJAg9++W98+S1SgqO/VYpEGBZcllyUzM8PJRnuGkYETc3D08LntHLHaF2svLMOCb0I/AN/Ii8o3AKHaMwDZb5lv92HZ6X+kgUa5q/bltYYIQa68kQeTM+eEx5RMSR+mQqmfZM9fZ1syiGT4+JjPUuxen1129DlFgAb/qpsYYAH4VrOkBJPJreeUWC8VOLbFDlPm1MPaRzlM6DIP6fqG9cT8G0ZAliGBcDjrYwMq5Q+54kFLw4S43920ZRQXj5aNIh2FQlki5PI/42EwLZTrw66EBv56VpPQMMCLfxh74Rl6xvthimW92ZNMneEmHdZUcVWSj66vBDvnZ2IGRXthU70V2NO5dfVzroXlgpQHaSg8Bv8RwJUaBXwDmGWBEfgH2+jDw10RKv1eDv5sp80t27+q4m3QYw3sJqd2c3lFoJhFaOelVgLCt6n5zpqGJmd6ylO32jzVcfYxfVydJlN7DMPuWTwB+JlH5V4BnPQr8MjTPACPyy7wXKYC/wFHxY6tlfoXpu0niJx3yd1bSD687zxtRpD5SyatHN8Srxw5qyatDN8SswmMcXFSjM40+qrlZGj/6UBf2NAz4CmzNJvBrKKk0QbqFx4jIV1iubnoGGMXOVcyXD7jCv3yJHe51lQ479B+TIQABCEAAAhAwEUA6mHCRGAIQgAAEIHB0AkiHo0cA/kMAAhCAAARMBJAOJlwkhgAEIAABCBydANLh6BGA/xCAAAQgAAETAaSDCReJIQABCEAAAkcngHQ4egTgPwQgAAEIQMBEAOlgwkViCEAAAhCAwNEJIB2OHgH4DwEIQAACEDARcJUOatat1pWcJuPVhIb9883Ns0l2TwHp6aOa1i1Pijz5fymLoQAAEk5JREFUb97wNAz4RvzANwKbZ5Mk8mvQeQYYxU4NcZXGFb7Kd9+bjtJBLSkUWKdlI5r4SMmS5p8O1VjPXNRiTJ5/unMNC71yT7ePelWb3mUUXA0DvjFmiXwbMCLfxsv16Qb+E8I3XnrTyd2kg47ItF5lc2+BruzHMazSm+t+O0xVEeblg1uFiKePujjIy380iy1Pw4BvjDHgG4EppUXkV7DzDDCKnQrgOokrfJ3x7re9pIP0DcyDFKFFPq1MaIW0vFup87y1Wl2WU3HkolHTePoY9NC8krjom0EBtCHzNAz4NvYj8I3A5Bkk8uuheQYYxU4995DSFb7x2htP7ikdYu0udc9wf1o1Xi0YJIfYMRAkyP275f2zZDWKyk49FmlQYFlyWTITM7x8lGc4KRgRN3cPj8veEYtdofbyMgz4JvQj8I28iHwjMIodI7DNlvlWP7ad3lc6SJSrWn9uW5ggxNorSRA5c354TPmExFE6pOpZ9sx1tjWzaIaPj8kM9e7F6XVXr0MUWMCvuqkxBoBfBWt6AIn8Wl65xUKxU0vsEGV+LYx9pPOUDsOgvl9ob9yPQTRkCSIYl4MONrBy7pA7HqQUfLjLzX1bRlHBePko0mEYlCVSLs8jPjbTQpkO/HpowK9nJSk9A4zIt7EHvpFXrC+2WOabHdn0CV7SYV0lRxXZ6PpqsEN+NnZgpBc21XuRHY17Vx/XemgeWGmAttJDwC8xXIlR4BeAeQYYkV+AvT4M/DWR0u/V4O9myvyS3bs67iYdxvBeQmo3p3cUmkmEVk56FSBsq7rfnGloYqa3LGW7/WMNVx/j19VJEqX3MMy+5ROAn0lU/hXgWY8CvwzNM8CI/DLvRQrgL3BU/NhqmV9h+m6S+EmH/J2V9MPrzvNGFKmPVPLq0Q3x6rGDWvLq0A0xq/AYBxfV6Eyjj2pulsaPPtSFPQ0DvgJbswn8GkoqTZBu4TEi8hWWq5ueAUaxcxXz5QOu8C9fYod7XaXDDv3HZAhAAAIQgAAETASQDiZcJIYABCAAAQgcnQDS4egRgP8QgAAEIAABEwGkgwkXiSEAAQhAAAJHJ4B0OHoE4D8EIAABCEDARADpYMJFYghAAAIQgMDRCSAdjh4B+A8BCEAAAhAwEUA6mHCRGAIQgAAEIHB0AkiHo0cA/kMAAhCAAARMBFylg5p1q3Ulp8l4NaFh/3xz82yS3VNAevqopnXLkyJP/ps3PA0DvhE/8I3A5tkkifwadJ4BRrFTQ1ylcYWv8t33pqN0UEsKBdZp2YgmPlKypPmnQzXWMxe1GJPnn+5cw0Kv3NPto17VpncZBVfDgG+MWSLfBozIt/FyfbqB/4TwjZfedHI36aAjMq1X2dxboCv7cQyr9Oa63w5TVYR5+eBWIeLpoy4O8vIfzWLL0zDgG2MM+EZgSmkR+RXsPAOMYqcCuE7iCl9nvPttL+kgfQPzIEVokU8rE1ohLe9W6jxvrVaX5VQcuWjUNJ4+Bj00ryQu+mZQAG3IPA0Dvo39CHwjMHkGifx6aJ4BRrFTzz2kdIVvvPbGk3tKh1i7S90z3J9WjVcLBskhdgwECXL/bnn/LFmNorJTj0UaFFiWXJbMxAwvH+UZTgpGxM3dw+Oyd8RiV6i9vAwDvgn9CHwjLyLfCIxixwhss2W+1Y9tp/eVDhLlqtaf2xYmCLH2ShJEzpwfHlM+IXGUDql6lj1znW3NLJrh42MyQ717cXrd1esQBRbwq25qjAHgV8GaHkAiv5ZXbrFQ7NQSO0SZXwtjH+k8pcMwqO8X2hv3YxANWYIIxuWggw2snDvkjgcpBR/ucnPfllFUMF4+inQYBmWJlMvziI/NtFCmA78eGvDrWUlKzwAj8m3sgW/kFeuLLZb5Zkc2fYKXdFhXyVFFNrq+GuyQn40dGOmFTfVeZEfj3tXHtR6aB1YaoK30EPBLDFdiFPgFYJ4BRuQXYK8PA39NpPR7Nfi7mTK/ZPeujrtJhzG8l5DazekdhWYSoZWTXgUI26ruN2campjpLUvZbv9Yw9XH+HV1kkTpPQyzb/kE4GcSlX8FeNajwC9D8wwwIr/Me5EC+AscFT+2WuZXmL6bJH7SIX9nJf3wuvO8EUXqI5W8enRDvHrsoJa8OnRDzCo8xsFFNTrT6KOam6Xxow91YU/DgK/A1mwCv4aSShOkW3iMiHyF5eqmZ4BR7FzFfPmAK/zLl9jhXlfpsEP/MRkCEIAABCAAARMBpIMJF4khAAEIQAACRyeAdDh6BOA/BCAAAQhAwEQA6WDCRWIIQAACEIDA0QkgHY4eAfgPAQhAAAIQMBFAOphwkRgCEIAABCBwdAJIh6NHAP5DAAIQgAAETASQDiZcJIYABCAAAQgcnQDS4egRgP8QgAAEIAABEwFX6aBm3WpdyWkyXk1o2D/f3DybZPcUkJ4+qmnd8qTIk//mDU/DgG/ED3wjsHk2SSK/Bp1ngFHs1BBXaVzhq3z3vekoHdSSQoF1WjaiiY+ULGn+6VCN9cxFLcbk+ac717DQK/d0+6hXteldRsHVMOAbY5bItwEj8m28XJ9u4D8hfOOlN53cTTroiEzrVTb3FujKfhzDKr257rfDVBVhXj64VYh4+qiLg7z8R7PY8jQM+MYYA74RmFJaRH4FO88Ao9ipAK6TuMLXGe9+20s6SN/APEgRWuTTyoRWSMu7lTrPW6vVZTkVRy4aNY2nj0EPzSuJi74ZFEAbMk/DgG9jPwLfCEyeQSK/HppngFHs1HMPKV3hG6+98eSe0iHW7lL3DPenVePVgkFyiB0DQYLcv1veP0tWo6js1GORBgWWJZclMzHDy0d5hpOCEXFz9/C47B2x2BVqLy/DgG9CPwLfyIvINwKj2DEC22yZb/Vj2+l9pYNEuar157aFCUKsvZIEkTPnh8eUT0gcpUOqnmXPXGdbM4tm+PiYzFDvXpxed/U6RIEF/KqbGmMA+FWwpgeQyK/llVssFDu1xA5R5tfC2Ec6T+kwDOr7hfbG/RhEQ5YggnE56GADK+cOueNBSsGHu9zct2UUFYyXjyIdhkFZIuXyPOJjMy2U6cCvhwb8elaS0jPAiHwbe+AbecX6YotlvtmRTZ/gJR3WVXJUkY2urwY75GdjB0Z6YVO9F9nRuHf1ca2H5oGVBmgrPQT8EsOVGAV+AZhngBH5Bdjrw8BfEyn9Xg3+bqbML9m9q+Nu0mEM7yWkdnN6R6GZRGjlpFcBwraq+82ZhiZmestStts/1nD1MX5dnSRReg/D7Fs+AfiZROVfAZ71KPDL0DwDjMgv816kAP4CR8WPrZb5FabvJomfdMjfWUk/vO48b0SR+kglrx7dEK8eO6glrw7dELMKj3FwUY3ONPqo5mZp/OhDXdjTMOArsDWbwK+hpNIE6RYeIyJfYbm66RlgFDtXMV8+4Ar/8iV2uNdVOuzQf0yGAAQgAAEIQMBEAOlgwkViCEAAAhCAwNEJIB2OHgH4DwEIQAACEDARQDqYcJEYAhCAAAQgcHQCSIejRwD+QwACEIAABEwEkA4mXCSGAAQgAAEIHJ0A0uHoEYD/EIAABCAAARMBpIMJF4khAAEIQAACRyeAdDh6BOA/BCAAAQhAwEQA6WDCRWIIQAACEIDA0Qm4Sgc1YWfrIpDT/VBzIfdPVTtPRN09e7Snj2pG2LyewuS/ecPTMOAb8QPfCGyeiJrIr0HnGWAUOzXEVRpX+CrffW86Sge1GmFgnVacauIjJUtauiJUYz3LWIgxeemKzuWv9KJ/3T7qBfF6V2ByNQz4xpgl8m3AiHwbL9enG/hPCN946U0nd5MOOiLTUtfNvQW6sh/Hsa++VxXhOI5dQsTTR10c5JXDmsWWp2HANz6wwDcCU0qLyK9g5xlgFDsVwHUSV/g6491ve0kHqZLnQYrQIp8WNbZCWt6t1HneWq0uy6k4ctGoaTx9DHoorbidlNagANqQeRoGfBv7IEaJfAM0eQaJ/Hpgnk83xU4995DSFb7x2htP7ikdYu0udc9wf1o1Xi0YJIc4QhEkyP275f2zZDWKyk6jFWlQYFlyWTITM7x8lGc4KRgRN3cPj8veEYtdofbyMgz4JvSxHwv4BmhEvgFW6ij1CjCKHRt716LVeOmtJ/eVDlK5qlp/bluYMMTaK0kQOXOus035hMRROqTqWfbMJZc1s2iGj4/JDDUWc3rd1esQBRbwq25qjAHgV8GaHkAiv5ZXbrFQ7NQSO0SZXwtjH+k8pcMwqO8X2hv3YxANWYIIxuWggw2snDvkjgcpBR/ucnPfllF6T8LJR5EOw6AskXJ57ve2mRbKdCfDgG9jH3QtkW+ARuQbYCXd5hVgFDs29q5Pt/HSW0/uJR3WVXJUkY3erwY75GdjB0Z6jUB9oNHRuHf1ca2H5oGVBmgrPQT8EsOVGAV+AZhngBH5Bdjrw8BfEyn9Xg3+bqbML9m9q+Nu0mEM7yWkdnN6R6GZRGhGp1cBVDdpW36hlRMHC4Pozh9qNuTm6WP8ujpJovQeRoNJ8RRPw4BvvA3ANwKTaM+NASK/DM8zwCh2yrwXKVzhL3Le+Q8/6ZC/s5J+eN153ggodcJLXqrPoDGz2EcqeXXohnjtEEnBRTU602iWmpul8aMPdWFPw4CvwNZsAr+GkkoT1EN4jIh8heXqpmeAUexcxXz5gCv8y5fY4V5X6bBD/zEZAhCAAAQgAAETAaSDCReJIQABCEAAAkcngHQ4egTgPwQgAAEIQMBEAOlgwkViCEAAAhCAwNEJIB2OHgH4DwEIQAACEDARQDqYcJEYAhCAAAQgcHQCSIejRwD+QwACEIAABEwEkA4mXCSGAAQgAAEIHJ0A0uHoEYD/EIAABITAPHWew3x3IP2yCbhKBzXrVutKThNtNaFh/3xzjo+Ep49qWrc8L+/kv3nD0zDgG/ED3whsnk2SyK9B5xlgxWJntcJLjX2kORwBR+mgAi4Eelo2ogmplCxp/ulQjfXMRS3G5PmnRUPk7RbDPH3Uq9r0zuSvlxQCfsWdBX4FJJ2EyNc0KrZ3XOyoe13hKEmOScBNOuiyOK1X2dxboJ+61I3WXt8rFZJXsG0VIp4+6so+L//RLLY8DQO+sSQAvhHYsmbqU7rA/wTwlzfIeAGSH4SAl3SQvoF5kCIUB9PieFaUy+IgdZ63VqvLxyCOXDRqGk8fw7DivJJ47L+dAdqQeRoGfBv7EfhGYPIMEvn10DwDrK7YWZaZ9ZaS8kgEPKVDrN2l7hnuT6vGq4Wp5BA7BlKLZPnwWLIapXGfeizSoMCy5LJkJmZ4+SjPcFIw8qDePTwue0csdoXay8sw4JvQj8A38iLyjcA+f7GDdDDeokMm95UOEuWq1p/bFia2sfZKEkTOnB8eUz4hcZQOqXqWPXOdbc0smuHjYzJDvXtxeq26bWymeRoGfBv7FJw+UQF84J8R8Hy664odpMPZTWDHGQFP6TAM6pOe9sb9GERDliBicU8oy7n61UjJvGPAwstHeYaHQVkiBUTPgIWXYcA/e0Zu7wiigci/DUkfJfI1jfK2Z4DVFTs95W3ZH1J8GQS8pEOo71WVHNtPjYxWgx3ys7EDI72wqd6L7Gjcu/q41kPzwEoDtJUeAn6J4apwBH4BmGeAEfkF2OvDnx3+6ulY28NvCIzj6CYdxvBeQmo3p3cUmgkHoZ2ESNhWdb8509DKSW9Zynb7xxquPsavq5MkSu9hmH3LJwA/k6j8G95LBX4lrZHIryaVE+642EE65JvI3+sE/KRD/sJQ+uF1/+31a988krrpJK8e3RCvEftIJa8O3RCzCpV0cFGNztz05MbBUIGFzFSHzY30tw55Ggb8W6QvHAP+BSi3dhH5t+icH/MMMDUl1OViB+lwfgPYsybgKh3WmfMbAhCAAAT2RQDpsK/79TTWIh2ehjtXhQAEILBJAkiHTd6WjRmFdNjYDcEcCEAAAk9CYB7YdRiNfRIPuOhnI4B0+GyouRAEIAABCEDgSyCAdPgS7iI+QAACEIAABD4bAaTDZ0PNhSAAAQhAAAJfAgGkw5dwF/EBAhCAAAQg8NkIIB0+G2ouBAEIQAACEPgSCCAdvoS7iA8QgAAEIACBz0bgM0iHrXwlPE9gV1wRwzx3m0y/aF28SqamT/+aVuiQL6lsJ64mw/9sQfZ0F5LYi/+sd+cz2BwDYIOGfQbfuQQEILBrAkeRDqGYtlW0lhU7W6RDihu7Amg+sV46iMzqn/97K09Gx935VC5Ek36RJVUeHj/VRcgXAhCAwKch8P9Ad6zbPYHHYgAAAABJRU5ErkJggg==)
"""

# Plot
plt.figure(figsize=(12,4))
p1 = plt.subplot(121)
size_vertex_plot = 33
plt.scatter(Xtrain[:,0], Xtrain[:,1], s=size_vertex_plot*np.ones(n), c=l_train, color=pyplot.jet())
plt.title('Training Data: Labeled Data in red (first class)\n and blue (second class), \n and unlabeled Data in green (data geometry)')
plt.colorbar()
p2 = plt.subplot(122)
size_vertex_plot = 33
plt.scatter(Xtest[:,0], Xtest[:,1], s=size_vertex_plot*np.ones(n), c=Cgt_test, color=pyplot.jet())
plt.title('Test Data')
plt.colorbar()
# plt.tight_layout()
plt.show()

"""### Kernel SVM

Запустите код ниже и обратите внимание какое внимание будет получено качество, включая визульное разделение классов
"""

# Run kernel SVM

# Compute Gaussian kernel, L, Q
sigma = 0.5; sigma2 = sigma**2
Ddist = sklearn.metrics.pairwise.pairwise_distances(Xtrain, Xtrain, metric='euclidean', n_jobs=1)
Ker = np.exp(- Ddist**2 / sigma2)
Ddist = sklearn.metrics.pairwise.pairwise_distances(Xtrain, Xtest, metric='euclidean', n_jobs=1)
KXtest = np.exp(- Ddist**2 / sigma2)
l = l_train
L = np.diag(l)
Q = L.dot(Ker.dot(L))

# Time steps
tau_alpha = 10/ np.linalg.norm(Q,2)
tau_beta = 0.1/ np.linalg.norm(L,2)

# For conjuguate gradient
Acg = tau_alpha* Q + np.eye(n)

# Pre-compute J.K(Xtest) for test data
LKXtest = L.dot(KXtest)

# Error parameter
lamb = 3 # acc: 73.8

# Initialization
alpha = np.zeros([n])
beta = np.zeros([n])
alpha_old = alpha

# Loop
k = 0
diff_alpha = 1e6
num_iter = 201
while (diff_alpha>1e-3) & (k<num_iter):

    # Update iteration
    k += 1

    # Update alpha
    # Approximate solution with conjuguate gradient
    b0 = alpha + tau_alpha - tau_alpha* l* beta
    alpha, _ = scipy.sparse.linalg.cg(Acg, b0, x0=alpha, tol=1e-3, maxiter=50)
    alpha[alpha<0.0] = 0 # Projection on [0,+infty]
    alpha[alpha>lamb] = lamb # Projection on [-infty,lamb]

    # Update beta
    beta = beta + tau_beta* l.T.dot(alpha)

    # Stopping condition
    diff_alpha = np.linalg.norm(alpha-alpha_old)
    alpha_old = alpha

    # Plot
    if not(k%100) or (diff_alpha<1e-3):

        # Indicator function of support vectors
        idx = np.where( np.abs(alpha)>0.25* np.max(np.abs(alpha)) )
        Isv = np.zeros([n]); Isv[idx] = 1
        nb_sv = len(Isv.nonzero()[0])

        # Offset
        if nb_sv > 1:
            b = (Isv.T).dot( l - Ker.dot(L.dot(alpha)) )/ nb_sv
        else:
            b = 0

        # Continuous score function
        f_test = alpha.T.dot(LKXtest) + b

        # Binary classification function
        C_test = np.sign(f_test) # decision function in {-1,1}
        accuracy_test = compute_purity(0.5*(1+C_test),Cgt_test,nc) # 0.5*(1+C_test) in {0,1}

        # Plot
        size_vertex_plot = 33
        plt.figure(figsize=(12,4))
        p1 = plt.subplot(121)
        plt.scatter(Xtest[:,0], Xtest[:,1], s=size_vertex_plot*np.ones(n), c=f_test, color=pyplot.jet())
        plt.title('Score function $s(x)=w^T\phi(x)+b$ \n iter=' + str(k)+ ', diff_alpha=' + str(diff_alpha)[:7])
        plt.colorbar()
        p2 = plt.subplot(122)
        plt.scatter(Xtest[:,0], Xtest[:,1], s=size_vertex_plot*np.ones(n), c=C_test, color=pyplot.jet())
        plt.title('Classification function $f(x)=sign(w^T\phi(x)+b)$\n iter=' + str(k) + ', acc=' + str(accuracy_test)[:5])
        #plt.tight_layout()
        plt.colorbar()
        plt.show()
        if k<num_iter-1:
            clear_output(wait=True)

"""В первой части кода (kernel SVM) достигается точность около 73.8%, что является средним результатом. Визуально видно, что разделение классов не идеальное, особенно в областях, где классы пересекаются. Это объясняется тем, что классический SVM не учитывает структуру данных и работает только с размеченными примерами.

### Graph SVM
"""

# Compute Gaussian kernel
sigma = 0.15; sigma2 = sigma**2
Ddist = sklearn.metrics.pairwise.pairwise_distances(Xtrain, Xtrain, metric='euclidean', n_jobs=1)
Ker = np.exp(- Ddist**2 / sigma2)
Ddist = sklearn.metrics.pairwise.pairwise_distances(Xtrain, Xtest, metric='euclidean', n_jobs=1)
KXtest = np.exp(- Ddist**2 / sigma2)

"""#### Задание 1: Постройте KNN-граф из обучающих данных и вычислите матрицу Лапласиана

Можно использовать `A = construct_knn_graph(data, k, dist_metric)` для генерации матрицы смежности KNN-графа из обучающего набора данных.

Переменные:
- `data`: Характеристики обучающих данных.
- `k`: Количество ближайших соседей.
- `dist_metric`: Матрица расстояния, например, с использованием евклидова расстояния `'euclidean'`, `'euclidean_zelnik_perona'` или `'cosine'`.
- `A`: Матрица смежности графа KNN.

Для получения матрицы лапласиана из матрицы смежности `A` можно использовать `Lap = graph_laplacian(A).todense()`.

"""

from sklearn.neighbors import kneighbors_graph
from scipy.sparse.csgraph import laplacian

# Построение KNN-графа
k = 10  # Число соседей
dist_metric = 'euclidean'  # Метрика расстояния
A = construct_knn_graph(Xtrain, kNN, 'cosine')

# Вычисление матрицы Лапласиана
Lap = graph_laplacian(A).todense()

# Проверка
print("Матрица смежности A:\n", A.toarray())
print("Матрица Лапласиана Lap:\n", Lap)

"""#### Задание 2: Вычислите индикаторную функцию меток

"""

H = np.zeros([n])
H[np.abs(l_train)>0.0] = 1
H = np.diag(H)

"""#### Задание 3: Вычислите $L,\ Q$ для графа SVM

Формулы (раскрыты в лекции):
- $L = \text{Diag}(l)$
- $Q = LHK(I+\gamma \mathcal{L}K)^{-1}HL$.

Можно использовать функции:
* `np.diag()`: Диагональная матрица из вектора.
* `np.eye()`: Матрица тождества.
* `np.linalg.inv()`: Обратная матрица.
"""

gamma = 25

# Compute L, Q
L = np.diag(l_train)
l = l_train
T = np.eye(n)
T += gamma* Lap.dot(Ker)
Tinv = np.linalg.inv(T)
Q = L.dot(H.dot(Ker.dot(Tinv.dot(H.dot(L)))))

# Run Graph SVM

# Time steps
tau_alpha = 1/ np.linalg.norm(Q,2)
tau_beta = 1/ np.linalg.norm(L,2)

# For conjuguate gradient
Acg = tau_alpha* Q + np.eye(n)

# Error parameter
lamb = 1 # acc: 98.6

# Initialization
alpha = np.zeros([n])
beta = np.zeros([n])
alpha_old = alpha

# Loop
k = 0
diff_alpha = 1e6
num_iter = 201
while (diff_alpha>1e-3) & (k<num_iter):

    # Update iteration
    k += 1

    # Update alpha
    # Approximate solution with conjuguate gradient
    b0 = alpha + tau_alpha - tau_alpha* l* beta
    alpha, _ = scipy.sparse.linalg.cg(Acg, b0, x0=alpha, tol=1e-3, maxiter=50)
    alpha[alpha<0.0] = 0 # Projection on [0,+infty]
    alpha[alpha>lamb] = lamb # Projection on [-infty,lamb]

    # Update beta
    beta = beta + tau_beta* l.T.dot(alpha)

    # Stopping condition
    diff_alpha = np.linalg.norm(alpha-alpha_old)
    alpha_old = alpha

    # Plot
    if not(k%100) or (diff_alpha<1e-3):

        # xi vector
        xi = Tinv.dot(H.dot(L.dot(alpha)))

        # Offset
        idx_unlabeled_data = np.where( np.abs(l)<1./2 )
        alpha_labels = alpha; alpha_labels[idx_unlabeled_data] = 0
        idx = np.where( np.abs(alpha_labels)>0.25* np.max(np.abs(alpha_labels)) )
        Isv = np.zeros([n]); Isv[idx] = 1 # Indicator function of Support Vectors
        nb_sv = len(Isv.nonzero()[0])
        if nb_sv > 1:
            b = (Isv.T).dot( l - Ker.dot(np.squeeze(np.array(xi))) )/ nb_sv
        else:
            b = 0

        # Continuous score function
        f_test = np.squeeze(np.array(xi.dot(KXtest) + b))

        # Binary classification function
        C_test = np.sign(f_test) # decision function in {-1,1}
        print('C_test',C_test.shape)
        accuracy_test = compute_purity(0.5*(1+C_test),Cgt_test,nc) # 0.5*(1+C_test) in {0,1}

        # Plot
        size_vertex_plot = 33
        plt.figure(figsize=(12,4))
        p1 = plt.subplot(121)
        plt.scatter(Xtest[:,0], Xtest[:,1], s=size_vertex_plot*np.ones(n), c=f_test, color=pyplot.jet())
        plt.title('Score function $s(x)=w^T\phi(x)+b$ \n iter=' + str(k)+ ', diff_alpha=' + str(diff_alpha)[:7])
        plt.colorbar()
        p2 = plt.subplot(122)
        plt.scatter(Xtest[:,0], Xtest[:,1], s=size_vertex_plot*np.ones(n), c=C_test, color=pyplot.jet())
        plt.title('Classification function $f(x)=sign(w^T\phi(x)+b)$\n iter=' + str(k) + ', acc=' + str(accuracy_test)[:5])
        #plt.tight_layout()
        plt.colorbar()
        plt.show()
        if k<num_iter-1:
            clear_output(wait=True)

"""## Реальные данные

Набор содержит 50 статей (представлен в виде вектора), из которых только 10 размечены, а 40 - нет.
"""

# Dataset
mat = scipy.io.loadmat('datasets/data_20news_10labels_40unlabels.mat')
Xtrain = mat['Xtrain']
n = Xtrain.shape[0]
l_train = mat['l'].squeeze()
d = Xtrain.shape[1]
Xtest = mat['Xtest']
Cgt_test = mat['Cgt_test'] - 1; Cgt_test = Cgt_test.squeeze()
nc = len(np.unique(Cgt_test))
print(n,d,nc)
num_labels = np.sum(np.abs(l_train)>0.0)
print('l_train:',l_train)
print('number of labeled data per class:',num_labels//2)
print('number of unlabeled data:',n-num_labels)

"""### Kernel SVM

Запустите код ниже и обратите внимание какое внимание будет получено качество
"""

# Run Kernel SVM (no graph information)

# Compute Gaussian kernel
sigma = 0.5; sigma2 = sigma**2
Ddist = sklearn.metrics.pairwise.pairwise_distances(Xtrain, Xtrain, metric='euclidean', n_jobs=1)
Ker = np.exp(- Ddist**2 / sigma2)
Ddist = sklearn.metrics.pairwise.pairwise_distances(Xtrain, Xtest, metric='euclidean', n_jobs=1)
KXtest = np.exp(- Ddist**2 / sigma2)

# Compute kNN graph
kNN = 5
gamma = 0 # <= no graph information
A = construct_knn_graph(Xtrain, kNN, 'cosine')
Lap = graph_laplacian(A).todense()

# Compute Indicator function of labels
H = np.zeros([n])
H[np.abs(l_train)>0.0] = 1
H = np.diag(H)

# Compute L, Q
L = np.diag(l_train)
l = l_train
T = np.eye(n)
T += gamma* Lap.dot(Ker)
Tinv = np.linalg.inv(T)
Q = L.dot(H.dot(Ker.dot(Tinv.dot(H.dot(L)))))

# Time steps
tau_alpha = 1/ np.linalg.norm(Q,2)
tau_beta = 1/ np.linalg.norm(L,2)

# For conjuguate gradient
Acg = tau_alpha* Q + 1* np.eye(n)

# Error parameter
lamb = 100

# Initialization
alpha = np.zeros([n])
beta = np.zeros([n])
alpha_old = alpha

# Loop
k = 0
diff_alpha = 1e6
num_iter = 1001
while (diff_alpha>1e-3) & (k<num_iter):

    # Update iteration
    k += 1

    # Update alpha
    # Approximate solution with conjuguate gradient
    b0 = alpha + tau_alpha - tau_alpha* l* beta
    alpha, _ = scipy.sparse.linalg.cg(Acg, b0, x0=alpha, tol=1e-3, maxiter=50)
    alpha[alpha<0.0] = 0 # Projection on [0,+infty]
    alpha[alpha>lamb] = lamb # Projection on [-infty,lamb]

    # Update beta
    beta = beta + tau_beta* l.T.dot(alpha)

    # Stopping condition
    diff_alpha = np.linalg.norm(alpha-alpha_old)
    alpha_old = alpha

    # Plot
    if not(k%100) or (diff_alpha<1e-3):

        # xi vector
        xi = Tinv.dot(H.dot(L.dot(alpha)))

        # Offset
        idx_unlabeled_data = np.where( np.abs(l)<1./2 )
        alpha_labels = alpha; alpha_labels[idx_unlabeled_data] = 0
        idx = np.where( np.abs(alpha_labels)>0.25* np.max(np.abs(alpha_labels)) )
        Isv = np.zeros([n]); Isv[idx] = 1 # Indicator function of Support Vectors
        nb_sv = len(Isv.nonzero()[0])
        if nb_sv > 1:
            b = (Isv.T).dot( l - Ker.dot(np.squeeze(np.array(xi))) )/ nb_sv
        else:
            b = 0

        # Continuous score function
        f_test = xi.dot(KXtest) + b

        # Binary classification function
        C_test = np.sign(f_test) # decision function in {-1,1}
        accuracy_test = compute_purity(0.5*(1+C_test),Cgt_test,nc) # 0.5*(1+C_test) in {0,1}

print('Kernel SVM  iter, diff_alpha :',str(k),str(diff_alpha)[:7])
print('            acc :',str(accuracy_test)[:5])

"""### Graph SVM

#### Задание 4: Сравните результаты с kernel SVM и сделайте вывод о том, почему graph SVM превосходит kernel SVM на реальных данных?
"""

# Run Graph SVM

# Compute Gaussian kernel
sigma = 0.5; sigma2 = sigma**2
Ddist = sklearn.metrics.pairwise.pairwise_distances(Xtrain, Xtrain, metric='euclidean', n_jobs=1)
Ker = np.exp(- Ddist**2 / sigma2)
Ddist = sklearn.metrics.pairwise.pairwise_distances(Xtrain, Xtest, metric='euclidean', n_jobs=1)
KXtest = np.exp(- Ddist**2 / sigma2)

# Compute kNN graph
kNN = 8
gamma = 100
A = construct_knn_graph(Xtrain, kNN, 'cosine')
Lap = graph_laplacian(A).todense()

# Compute Indicator function of labels
H = np.zeros([n])
H[np.abs(l_train)>0.0] = 1
H = np.diag(H)

# Compute L, Q
L = np.diag(l_train)
l = l_train
T = np.eye(n)
T += gamma* Lap.dot(Ker)
Tinv = np.linalg.inv(T)
Q = L.dot(H.dot(Ker.dot(Tinv.dot(H.dot(L)))))

# Time steps
tau_alpha = 1/ np.linalg.norm(Q,2)
tau_beta = 1/ np.linalg.norm(L,2)

# For conjuguate gradient
Acg = tau_alpha* Q + 1* np.eye(n)

# Error parameter
lamb = 1

# Initialization
alpha = np.zeros([n])
beta = np.zeros([n])
alpha_old = alpha

# Loop
k = 0
diff_alpha = 1e6
num_iter = 1001
while (diff_alpha>1e-3) & (k<num_iter):

    # Update iteration
    k += 1

    # Update alpha
    # Approximate solution with conjuguate gradient
    b0 = alpha + tau_alpha - tau_alpha* l* beta
    alpha, _ = scipy.sparse.linalg.cg(Acg, b0, x0=alpha, tol=1e-3, maxiter=50)
    alpha[alpha<0.0] = 0 # Projection on [0,+infty]
    alpha[alpha>lamb] = lamb # Projection on [-infty,lamb]

    # Update beta
    beta = beta + tau_beta* l.T.dot(alpha)

    # Stopping condition
    diff_alpha = np.linalg.norm(alpha-alpha_old)
    alpha_old = alpha

    # Plot
    if not(k%100) or (diff_alpha<1e-3):

        # xi vector
        xi = Tinv.dot(H.dot(L.dot(alpha)))

        # Offset
        idx_unlabeled_data = np.where( np.abs(l)<1./2 )
        alpha_labels = alpha; alpha_labels[idx_unlabeled_data] = 0
        idx = np.where( np.abs(alpha_labels)>0.25* np.max(np.abs(alpha_labels)) )
        Isv = np.zeros([n]); Isv[idx] = 1 # Indicator function of Support Vectors
        nb_sv = len(Isv.nonzero()[0])
        if nb_sv > 1:
            b = (Isv.T).dot( l - Ker.dot(np.squeeze(np.array(xi))) )/ nb_sv
        else:
            b = 0

        # Continuous score function
        f_test = xi.dot(KXtest) + b

        # Binary classification function
        C_test = np.sign(f_test) # decision function in {-1,1}
        accuracy_test = compute_purity(0.5*(1+C_test),Cgt_test,nc) # 0.5*(1+C_test) in {0,1}

print('Graph SVM  iter, diff_alpha :',str(k),str(diff_alpha)[:7])
print('           acc :',str(accuracy_test)[:5])

"""Ответ:

1) Точность (Accuracy).
Graph SVM: достиг 78.5% точности. Это значительно лучше, чем Kernel SVM.Kernel SVM: достиг 65.5% точности, что указывает на ограниченность подхода в сложных структурах данных.

2) Количество итераций.
Graph SVM: завершил обучение за 2 итерации, что свидетельствует о быстрой сходимости алгоритма при использовании графовой структуры.
Kernel SVM: потребовалось 1001 итерация, что указывает на более длительное время обучения и меньшую эффективность.

3) Использование структурных связей.
Graph SVM: использует граф k-ближайших соседей с метрикой косинусного расстояния для учета структурных связей между объектами. Это позволяет учитывать и размеченные, и неразмеченные данные, улучшая обобщение.
Kernel SVM: ограничен только использованием ядра без учета графовых связей, что приводит к менее точным результатам.

Итог:
Graph SVM превосходит Kernel SVM благодаря использованию графа k-ближайших соседей и графовой регуляризации, что позволяет моделировать структурные связи в данных и достигать более высокой точности при меньшем числе итераций.
Kernel SVM недостаточно эффективен для задач с малым количеством размеченных данных, так как не учитывает взаимодействие между объектами через графовые зависимости.

#### Задание 5: Постройте граф на тестовых данных
"""

# Plot graph of test data points
kNN = 8
A = construct_knn_graph(Xtest, kNN, 'cosine')
print(type(A), A.shape)

import networkx as nx
import networkx as nx
import matplotlib.pyplot as plt

A.setdiag(0)
A.eliminate_zeros()
G_nx = nx.from_scipy_sparse_array(A)

plt.figure(figsize=[10,10]) # Размер графика
pos = nx.spring_layout(G_nx) # Расположение узлов
nx.draw_networkx_nodes(G_nx, pos, node_size=50, node_color="blue") # Визуализация узлов
nx.draw_networkx_edges(G_nx, pos, alpha=0.5) # Визуализация рёбер
plt.title("Graph of Test Data")
plt.show()

"""# PageRank"""

# Commented out IPython magic to ensure Python compatibility.
# dateset & lib
!gdown 1VgWcm-AACnYjTyH0TU23u2rLJJx7WGVL --folder
!gdown 13uGMg9B0xvFNduOSMV_VzMzx-gRNJZOB --folder
# Load libraries
import numpy as np
import scipy.io
# %matplotlib inline
#%matplotlib notebook
from matplotlib import pyplot
import matplotlib.pyplot as plt
plt.rcParams.update({'figure.max_open_warning': 0})
import time
import sys; sys.path.insert(0, 'lib/')
import scipy.sparse.linalg
import warnings; warnings.filterwarnings("ignore")

"""## Синтетические данные"""

# Data matrix
mat = scipy.io.loadmat('datasets/pagerank_synthetic.mat')
W = mat['W']
W = scipy.sparse.csr_matrix(W)
Wref = W
X = mat['X']
n = X.shape[0]
d = X.shape[1]
E = mat['E']
XE = mat['X2']
print('num_nodes:',n)

plt.figure(1)
size_vertex_plot = 100
plt.scatter(X[:,0], X[:,1], s=size_vertex_plot*np.ones(n))
plt.quiver(XE[:,0], XE[:,1], E[:,0], E[:,1], scale=1., units='xy')
plt.title('Visualization of the artificial WWW')
plt.axis('equal')
plt.axis('off')
plt.show()

"""### Задание 6: Реализуйте PageRank с помощью спектрального подхода

####  Шаг 1: Постройте матрицу степеней D и ее обратную матрицу D$^{-1}$ из матрицы смежности W.

Учитывайте случаи, когда узел имеет нулевую степень.

Вам потребуются:
- `numpy.sum()`,
- `numpy.diag()`.
"""

# Solve eigenproblem

# vectors of 1's
e = np.ones([n,1])/n
one = np.ones([n,1])

D = np.array(W.sum(axis=1)).squeeze()  # Суммируем строки для получения степени узлов
a_idx = np.zeros([n], dtype='int32')
a_idx[np.where(D < 1. / 2)] = 1
a = (1.0 * a_idx)[:, None]  # Вектор a для узлов с малой степенью
# Обратная степень узлов, учитывая нулевые степени
invD = 1. / (D + 1e-10)
invD[a_idx == 1] = 0
invD = np.diag(invD)  # Создаем диагональную матрицу

"""#### Шаг 2: Преобразуйте матрицу смежности W в стохастическую и несводимую матрицу

Вам потребуются:
- `scipy.sparse.csr_matrix.todense()`,
- `numpy.dot()`,
- `.T`.
"""

W_dense = W.todense()  # Преобразуем W в плотную матрицу для обработки
P = np.dot(invD, W_dense)  # Строим стохастическую матрицу
alpha = 0.85
P_hat = alpha* P +  alpha* e.dot(a.T) + (1.0-alpha)* e.dot(one.T)

"""#### Шаг 3: Выполните разложение по собственным значениям (EVD) для стохастической и несводимой матрицы $\hat{P}$, чтобы получить решение PageRank.

Вам потребуются:
- `scipy.sparse.csr_matrix()` для преобразования матрицы NumPy в разреженную матрицу
- `scipy.sparse.linalg.eigs()` для вычисления собственных значений и собственных векторов.
"""

start = time.time()
P_hat_sparse = scipy.sparse.csr_matrix(P_hat)  # Преобразуем P_hat в разреженную матрицу
lamb, U = scipy.sparse.linalg.eigs(P_hat_sparse, k=1)  # Вычисляем собственные значения и векторы
x_pagerank = np.abs(U[:, 0]) / np.sum(np.abs(U[:, 0]))  # Нормируем первый собственный вектор

# Computational time
print('Computational time for PageRank solution with EIGEN Method (sec):',time.time() - start)

"""#### Шаг 4: Визуализируйте (реализация не требуется)"""

plt.figure(2)
size_vertex_plot = 1e3*6
plt.scatter(X[:,0], X[:,1], s=size_vertex_plot*x_pagerank)
plt.quiver(XE[:,0], XE[:,1], E[:,0], E[:,1], scale=1., units='xy')
plt.title('PageRank solution with EIGEN Method.')
plt.axis('equal')
plt.axis('off')
plt.show()

# PageRank values
x = x_pagerank
val = np.sort(x)[::-1]
idx = np.argsort(x)[::-1]
index = np.array(range(1,1+n))
in_degree = np.array(W.sum(axis=0)).squeeze(axis=0)
out_degree =  np.array(W.sum(axis=1)).squeeze(axis=1)
index = index[idx]
in_degree = in_degree[idx]
out_degree = out_degree[idx]
print('\n  ''Node'' | ''PageRank'' | ''In-degree'' | ''Out-degree'' ')
for i in range(n):
    print('   ',index[i], '  ', round(val[i],3) ,'      ', in_degree[i],'      ', out_degree[i], end='\n')

"""### Задание 7: Реализуйте PageRank с помощью метода степеней (Power Method)

"""

# Power Method

# Initialization
x = e
diffx = 1e10
k = 0

# Iterative scheme
start = time.time()
alpha = 0.85
while (k<1000) & (diffx>1e-6):

    # Update iteration
    k += 1

    # Update x
    xold = x

    x = alpha * P_hat.dot(xold) + (1 - alpha) * e

    # Stopping condition
    diffx = np.linalg.norm(x-xold,1)

x_pagerank_PM = np.array(x).squeeze(axis=1)

# Computational time
print('Computational time for PageRank solution with POWER Method (sec):',time.time() - start)

plt.figure(3)
size_vertex_plot = 1e3*6
plt.scatter(X[:,0], X[:,1], s=size_vertex_plot*x_pagerank)
plt.quiver(XE[:,0], XE[:,1], E[:,0], E[:,1], scale=1., units='xy')
plt.title('PageRank solution with POWER Method.')
plt.axis('equal')
plt.axis('off')
plt.show()

"""## Реальные данные

Граф был построен путем расширения набора ответов из 200 страниц, полученных в результате запроса «Калифорния» в поисковой системе.

"""

# data
network = np.loadtxt('datasets/california.dat')
row = network[:,0]-1
col = network[:,1]-1
n = int(np.max(network))+1 # nb of vertices
ne = len(row)
print('nb of nodes=',n)
print('nb of edges=',ne)

# Create Adjacency matrix W
data = np.ones([ne])
W = scipy.sparse.csr_matrix((data, (row, col)), shape=(n, n))
Wref = W
print(W.shape)

# Plot adjacency matrix
plt.figure(4)
plt.spy(W,precision=0.01, markersize=1)
plt.show()

# Solve eigenproblem

# vector of 1's
e = np.ones([n,1])/n
one = np.ones([n,1])

# Dumpling vector
D = np.array(W.sum(axis=1),dtype='float32').squeeze()
a_idx = np.zeros([n],dtype='int32')
a_idx[np.where(D<1./2)] = 1
a = (1.0* a_idx)[:,None]

# Compute P = W D^{-1}
invD = 1./(D+1e-10)
invD[a_idx==1] = 0
invD = np.diag(invD)
W = Wref.todense()
P = invD.dot(W).T

# EVD
alpha = 0.85
start = time.time()
Phat = alpha* P +  alpha* e.dot(a.T) + (1.0-alpha)* e.dot(one.T)
Phat = scipy.sparse.csr_matrix(Phat)
lamb, U = scipy.sparse.linalg.eigs(Phat, k=1, which='LM')
x_pagerank = np.abs(U[:,0])/ np.sum(np.abs(U[:,0]))

# Computational time
print('Computational time for PageRank solution with EIGEN Method (sec):',time.time() - start)

# Power Method

# Initialization
x = e
diffx = 1e10
k = 0

# Iterative scheme
start = time.time()
alpha = 0.85
while (k<1000) & (diffx>1e-6):

    # Update iteration
    k += 1

    # Update x
    xold = x
    x = alpha* P.dot(x) + e.dot( alpha* a.T.dot(x) + (1.0-alpha) )

    # Stopping condition
    diffx = np.linalg.norm(x-xold,1)

x_pagerank_PM = np.array(x).squeeze(axis=1)

# Computational time
print('Computational time for PageRank solution with POWER Method (sec):',time.time() - start)

"""#### Задание 8: Сравните временную сложность  спектрального подхода $O(N^2)$ и метода степеней $O(E)$.

Результаты эксперимента показывают, что вычисление PageRank с использованием спектрального подхода заняло 15.96 секунды, в то время как метод степеней потребовал всего 4.47 секунды. Это подтверждает теоретические оценки временной сложности обоих методов. Спектральный подход, обладая сложностью порядка $O(N^2)$, оказывается значительно более затратным по времени, особенно на больших графах с большим числом узлов. Метод степеней, временная сложность которого составляет
𝑂(𝐸), где E — количество рёбер, демонстрирует заметное преимущество в вычислительной эффективности, особенно для разреженных графов, таких как рассматриваемый в данном эксперименте. Таким образом, для вычисления PageRank на крупных графах метод степеней предпочтителен благодаря его меньшим временным затратам.
"""