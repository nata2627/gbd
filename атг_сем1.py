# -*- coding: utf-8 -*-
"""АТГ_Сем1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sksErzpJsJ-_bHMB42SmCuxLgwFjG1Y0

## 1 задание

1. Построение динамического графа
"""

# Определяем основные типы операций для связного графа
def add_vertex_with_edge(G, level, total_levels):
    """Добавить новую вершину с ребром к случайной существующей."""
    new_node = max(G.nodes) + 1 if len(G.nodes) > 0 else 0
    existing_node = random.choice(list(G.nodes))
    weight = 1 + level / total_levels  # Вес зависит от уровня
    G.add_node(new_node)
    G.add_edge(new_node, existing_node, weight=weight)

def add_edge(G, level, total_levels):
    """Добавить ребро между двумя случайными несмежными вершинами."""
    nodes = list(G.nodes)
    if len(nodes) > 1:
        u, v = random.sample(nodes, 2)
        if not G.has_edge(u, v):
            weight = 1 + level / total_levels  # Вес зависит от уровня
            G.add_edge(u, v, weight=weight)

def replace_vertex_with_seed(G, seeds, vertex, level, total_levels):
    """Заменить вершину затравкой, сохраняя связь с соседями."""
    if vertex not in G:
        return
    seed_key = random.choice(list(seeds.keys()))
    seed_graph = seeds[seed_key]

    # Сохраняем соседей текущей вершины
    neighbors = list(G.neighbors(vertex))
    G.remove_node(vertex)

    # Добавляем вершины и рёбра затравки
    mapping = {}
    for n in seed_graph.nodes:
        if n == 0:
            mapping[n] = vertex  # Сохраняем место удалённой вершины
            G.add_node(vertex)
        else:
            new_node = max(G.nodes) + 1
            G.add_node(new_node)
            mapping[n] = new_node

    for u, v in seed_graph.edges:
        weight = 1 + level / total_levels  # Вес зависит от уровня
        G.add_edge(mapping[u], mapping[v], weight=weight)

    # Восстанавливаем соседей к центральной вершине
    for neighbor in neighbors:
        weight = 1 + level / total_levels  # Вес зависит от уровня
        G.add_edge(vertex, neighbor, weight=weight)

# Основная функция эволюции графа
def evolve_graph(initial_seed, levels, num_operations):
    G = nx.Graph()
    G.add_nodes_from(initial_seed.nodes)
    G.add_edges_from(initial_seed.edges)

    seeds = create_seed_graphs()
    stages = []
    G_list = []  # Список для сохранения всех траекторий графа

    for level in range(levels):
        for _ in range(num_operations):
            operation = random.choice(
                ["add_vertex", "add_edge", "replace_vertex"]
            )
            if operation == "add_vertex":
                add_vertex_with_edge(G, level, levels)
            elif operation == "add_edge":
                add_edge(G, level, levels)
            elif operation == "replace_vertex" and len(G.nodes) > 0:
                vertex = random.choice(list(G.nodes))
                replace_vertex_with_seed(G, seeds, vertex, level, levels)

        # Сохраняем текущее состояние графа
        stages.append((list(G.nodes), list(G.edges(data=True))))
        G_list.append(G.copy())  # Сохраняем текущую копию графа

        # Проверка на минимальное количество вершин
        if len(G.nodes) >= 200:
            break

    return G, stages, G_list

# Визуализация графа
def draw_graph(G):
    pos = nx.circular_layout(G)  # Раскладка графа
    edges = G.edges(data=True)

    # Отображаем рёбра с учётом их веса
    weights = [edge[2].get('weight', 1) for edge in edges]
    nx.draw(G, pos, with_labels=False, width=weights, node_size=10)
    plt.title("Эволюционный граф с весами рёбер")
    plt.show()

# Создание начального графа и эволюция
initial_seed = nx.complete_graph(5)  # Начальный граф - полный граф с 5 вершинами
levels = 25  # Увеличено число уровней
num_operations = 10  # Увеличено число операций на уровень
G, stages, G_list = evolve_graph(initial_seed, levels, num_operations)

# Подсчёт числа вершин
num_vertices = G.number_of_nodes()
print(f"Общее число вершин в графе: {num_vertices}")

# Визуализация финального графа
draw_graph(G)

# Проверка количества сохранённых траекторий
print(f"Сохранено траекторий графа: {len(G_list)}")

"""2-3 задания"""

import networkx as nx
import matplotlib.pyplot as plt
import random
import numpy as np

def calculate_graph_characteristics(G):
    """Вычислить топологические и метрические характеристики графа."""
    characteristics = {}
    try:
        characteristics['radius'] = nx.radius(G)
        characteristics['diameter'] = nx.diameter(G)
        characteristics['center'] = list(nx.center(G))
        characteristics['periphery'] = list(nx.periphery(G))
    except nx.NetworkXError:  # Случай, если граф несвязный
        characteristics['radius'] = None
        characteristics['diameter'] = None
        characteristics['center'] = []
        characteristics['periphery'] = []

    characteristics['node_connectivity'] = nx.node_connectivity(G)
    characteristics['edge_connectivity'] = nx.edge_connectivity(G)
    characteristics['articulation_points'] = list(nx.articulation_points(G))
    characteristics['bridges'] = list(nx.bridges(G))

    # Меры центральности
    characteristics['degree_centrality'] = nx.degree_centrality(G)
    characteristics['closeness_centrality'] = nx.closeness_centrality(G)
    characteristics['betweenness_centrality'] = nx.betweenness_centrality(G)

    # Степень вершин
    degrees = dict(G.degree)
    max_degree = max(degrees.values(), default=0)
    characteristics['max_degree'] = max_degree
    characteristics['max_degree_nodes'] = [n for n, d in degrees.items() if d == max_degree]

    # Диаметральные цепи (если граф связный)
    if characteristics['diameter'] is not None:
        nodes = list(G.nodes)
        diametral_paths = []
        for u in nodes:
            for v in nodes:
                if nx.shortest_path_length(G, u, v) == characteristics['diameter']:
                    diametral_paths.append(nx.shortest_path(G, u, v))
        characteristics['diametral_paths'] = diametral_paths
    else:
        characteristics['diametral_paths'] = []

    return characteristics

def visualize_graph(G, step, characteristics):
    """Визуализировать граф с выделением характеристик."""
    pos = nx.circular_layout(G)  # Рандомизированная раскладка
    plt.figure(figsize=(10, 8))

    # Рёбра
    nx.draw_networkx_edges(G, pos, alpha=0.5)

    # Вершины с максимальной степенью
    max_degree_nodes = characteristics['max_degree_nodes']
    nx.draw_networkx_nodes(G, pos, nodelist=max_degree_nodes, node_color='red', label='Max degree', node_size=150)

    # Точки сочленения
    articulation_points = characteristics['articulation_points']
    nx.draw_networkx_nodes(G, pos, nodelist=articulation_points, node_color='orange', label='Articulation points', node_size=150)

    # Центральные вершины
    center_nodes = characteristics['center']
    nx.draw_networkx_nodes(G, pos, nodelist=center_nodes, node_color='blue', label='Center', node_size=150)

    # Подписи
    labels = {node: node for node in G.nodes}
    nx.draw_networkx_labels(G, pos, labels, font_size=8)

    plt.title(f"Graph Step {step}\nRadius: {characteristics['radius']}, Diameter: {characteristics['diameter']}")
    plt.legend()
    plt.show()

# Рассчитать характеристики для всех графов в траектории
graph_characteristics = []
for i, graph in enumerate(G_list):
    char = calculate_graph_characteristics(graph)
    graph_characteristics.append(char)

# Визуализация 5 шагов
steps_to_visualize = np.linspace(0, len(G_list) - 1, 5, dtype=int)
for step in steps_to_visualize:
    visualize_graph(G_list[step], step, graph_characteristics[step])

"""4-6 задания"""

# Модифицированные функции для построения графа с ограничением изменения диаметра
def add_vertex_with_edge_diameter_constraint(G, level, total_levels, max_diameter_change):
    """Добавить вершину с ребром, сохраняя изменение диаметра не более чем на max_diameter_change."""
    new_node = max(G.nodes) + 1 if len(G.nodes) > 0 else 0
    existing_node = random.choice(list(G.nodes))
    weight = 1 + level / total_levels

    # Проверяем изменение диаметра
    temp_G = G.copy()
    temp_G.add_node(new_node)
    temp_G.add_edge(new_node, existing_node, weight=weight)

    if abs(nx.diameter(temp_G) - nx.diameter(G)) <= max_diameter_change:
        G.add_node(new_node)
        G.add_edge(new_node, existing_node, weight=weight)

def add_edge_diameter_constraint(G, level, total_levels, max_diameter_change):
    """Добавить ребро между двумя случайными несмежными вершинами, сохраняя изменение диаметра."""
    nodes = list(G.nodes)
    if len(nodes) > 1:
        u, v = random.sample(nodes, 2)
        if not G.has_edge(u, v):
            weight = 1 + level / total_levels
            temp_G = G.copy()
            temp_G.add_edge(u, v, weight=weight)

            if abs(nx.diameter(temp_G) - nx.diameter(G)) <= max_diameter_change:
                G.add_edge(u, v, weight=weight)

def replace_vertex_with_seed_diameter_constraint(G, seeds, vertex, level, total_levels, max_diameter_change):
    """Заменить вершину затравкой, сохраняя изменение диаметра."""
    if vertex not in G:
        return
    seed_key = random.choice(list(seeds.keys()))
    seed_graph = seeds[seed_key]

    neighbors = list(G.neighbors(vertex))
    temp_G = G.copy()
    temp_G.remove_node(vertex)

    # Добавляем вершины и рёбра затравки
    mapping = {}
    for n in seed_graph.nodes:
        if n == 0:
            mapping[n] = vertex
            temp_G.add_node(vertex)
        else:
            new_node = max(temp_G.nodes) + 1
            temp_G.add_node(new_node)
            mapping[n] = new_node

    for u, v in seed_graph.edges:
        weight = 1 + level / total_levels
        temp_G.add_edge(mapping[u], mapping[v], weight=weight)

    for neighbor in neighbors:
        weight = 1 + level / total_levels
        temp_G.add_edge(vertex, neighbor, weight=weight)

    # Проверяем изменение диаметра
    if abs(nx.diameter(temp_G) - nx.diameter(G)) <= max_diameter_change:
        G.clear()
        G.add_nodes_from(temp_G.nodes)
        G.add_edges_from(temp_G.edges)

# Основная функция эволюции с изменением диаметра
def evolve_graph_diameter_constraint(initial_seed, levels, num_operations, max_diameter_change):
    G = nx.Graph()
    G.add_nodes_from(initial_seed.nodes)
    G.add_edges_from(initial_seed.edges)

    seeds = create_seed_graphs()
    stages = []
    G_list = []

    for level in range(levels):
        for _ in range(num_operations):
            operation = random.choice(
                ["add_vertex", "add_edge", "replace_vertex"]
            )
            if operation == "add_vertex":
                add_vertex_with_edge_diameter_constraint(G, level, levels, max_diameter_change)
            elif operation == "add_edge":
                add_edge_diameter_constraint(G, level, levels, max_diameter_change)
            elif operation == "replace_vertex" and len(G.nodes) > 0:
                vertex = random.choice(list(G.nodes))
                replace_vertex_with_seed_diameter_constraint(G, seeds, vertex, level, levels, max_diameter_change)

        stages.append((list(G.nodes), list(G.edges(data=True))))
        G_list.append(G.copy())

        if len(G.nodes) >= 200:
            break

    return G, stages, G_list

# Создание новой траектории графов
max_diameter_change = 3
G_diameter, stages_diameter, G_list_diameter = evolve_graph_diameter_constraint(
    initial_seed, levels, num_operations, max_diameter_change
)

# Расчет характеристик для новой траектории
graph_characteristics_diameter = [
    calculate_graph_characteristics(graph) for graph in G_list_diameter
]

# Визуализация 5 графов для новой траектории
steps_to_visualize = np.linspace(0, len(G_list_diameter) - 1, 5, dtype=int)
for step in steps_to_visualize:
    visualize_graph(G_list_diameter[step], step, graph_characteristics_diameter[step])

import networkx as nx
import matplotlib.pyplot as plt
import pandas as pd
import random

# Функция для расчёта характеристик графа
def calculate_graph_properties(G):
    properties = {}

    try:
        properties["radius"] = nx.radius(G)
    except nx.NetworkXError:
        properties["radius"] = None

    try:
        properties["diameter"] = nx.diameter(G)
    except nx.NetworkXError:
        properties["diameter"] = None

    try:
        properties["center"] = nx.center(G)
    except nx.NetworkXError:
        properties["center"] = None

    try:
        properties["periphery"] = nx.periphery(G)
    except nx.NetworkXError:
        properties["periphery"] = None

    try:
        properties["node_connectivity"] = nx.node_connectivity(G)
    except nx.NetworkXError:
        properties["node_connectivity"] = None

    try:
        properties["edge_connectivity"] = nx.edge_connectivity(G)
    except nx.NetworkXError:
        properties["edge_connectivity"] = None

    properties["max_degree"] = max(dict(G.degree()).values(), default=0)
    properties["articulation_points"] = len(list(nx.articulation_points(G)))
    properties["bridges"] = len(list(nx.bridges(G)))
    properties["average_clustering"] = nx.average_clustering(G)
    properties["density"] = nx.density(G)

    return properties

# Функция для визуализации графа
def visualize_graph(G, step):
    plt.figure(figsize=(8, 8))
    pos = nx.circular_layout(G)
    nx.draw(G, pos, with_labels=True, node_color="lightblue", edge_color="gray", node_size=50, font_size=5)
    plt.title(f"Граф на шаге {step}")
    plt.show()

# Динамические графы без ограничения
graphs1 = [G.copy() for G in G_list]

# Динамические графы с ограничением на изменение диаметра
graphs2 = G_list_diameter

# Расчёт характеристик
properties_p2 = [calculate_graph_properties(G) for G in graphs1]
properties_p4 = [calculate_graph_properties(G) for G in graphs2]
df1 = pd.DataFrame(properties_p2)
df2 = pd.DataFrame(properties_p4)

steps = list(range(min(len(graphs1), len(graphs2))))
for i in range(5):  # Отобразить первые 5 графов
    visualize_graph(graphs2[i], steps[i])

df1

df2

"""### 2 задание"""

import networkx as nx
import matplotlib.pyplot as plt

# Функция для поиска цепных покрытий
def get_chain_cover(graph):
    chains = []
    visited = set()

    def explore_chain(start_node, current_chain):
        """
        Вспомогательная функция для поиска цепи, начиная с узла start_node.
        """
        visited.add(start_node)
        current_chain.append(start_node)

        # Рекурсивно добавляем соседей, если они не посещены
        for neighbor in graph[start_node]:
            if neighbor not in visited:
                explore_chain(neighbor, current_chain)

    # Проходим по всем вершинам графа
    for node in graph.nodes():
        if node not in visited:
            current_chain = []
            explore_chain(node, current_chain)
            chains.append(current_chain)

    return chains

# Функция для вычисления Парето-фронта
def calculate_pareto_front(cover):
    """
    Определяет Парето-фронт для цепей. В качестве критериев: длина цепи и количество цепей.
    """
    # Сортировка цепей по длине (от наибольшей к наименьшей)
    chain_lengths = [(len(chain), -i) for i, chain in enumerate(cover)]
    pareto_front = []

    # Для каждой цепи проверяем, не доминирует ли она другой
    for i, (length1, _) in enumerate(chain_lengths):
        is_dominated = False
        for j, (length2, _) in enumerate(chain_lengths):
            if i != j and length2 >= length1:
                is_dominated = True
                break
        if not is_dominated:
            pareto_front.append(cover[i])

    return pareto_front

# Функция для визуализации покрытия
def draw_cover(graph, cover, title):
    """
    Визуализирует граф с выделением покрытия.
    """
    plt.figure(figsize=(12, 12))
    pos = nx.circular_layout(graph)  # Позиционирование вершин с фиксированным началом

    # Рисуем сам граф
    nx.draw(graph, pos, with_labels=True, node_color="skyblue", edge_color="gray", node_size=500, font_size=10)

    # Для каждого покрытия рисуем ребра соответствующих цепей
    colors = ["red", "blue", "green", "purple", "orange"]
    for i, chain in enumerate(cover):
        edge_list = [(chain[j], chain[j+1]) for j in range(len(chain)-1)]
        if chain[0] == chain[-1]:  # Если это замкнутый цикл
            edge_list.append((chain[-1], chain[0]))

        # Рисуем ребра цепи соответствующим цветом
        nx.draw_networkx_edges(graph, pos, edgelist=edge_list, edge_color=colors[i % len(colors)], width=2)

    plt.title(title)
    plt.show()

# Основной процесс: анализ и визуализация
for idx, G in enumerate(G_list):
    # Находим цепные покрытия для текущего графа
    chains = get_chain_cover(G)
    print(f"Граф {idx}: Обнаружено цепных покрытий: {len(chains)}")

    # Рассчитываем Парето-фронт для покрытия
    pareto_front = calculate_pareto_front(chains)
    print(f"Граф {idx}: Парето-оптимальные цепи: {len(pareto_front)}")

    # Визуализируем покрытия для графа
    draw_cover(G, chains, f"Цепное покрытие (Граф {idx})")
    draw_cover(G, pareto_front, f"Парето-оптимальное покрытие (Граф {idx})")

import torch
import torch.nn as nn
import torch.nn.functional as F
from torch_geometric.nn import GCNConv, global_mean_pool
from torch_geometric.data import Data, DataLoader
from torch_geometric.utils import from_networkx
import torch_geometric.transforms as T

class GraphCoverPredictor(nn.Module):
    def __init__(self, input_dim=1, hidden_dim=64, output_dim=1):
        super(GraphCoverPredictor, self).__init__()
        self.conv1 = GCNConv(input_dim, hidden_dim)
        self.conv2 = GCNConv(hidden_dim, hidden_dim)
        self.conv3 = GCNConv(hidden_dim, hidden_dim)

        self.mlp = nn.Sequential(
            nn.Linear(hidden_dim, hidden_dim),
            nn.ReLU(),
            nn.Linear(hidden_dim, output_dim)
        )

    def forward(self, x, edge_index, batch):
        # Graph convolution layers
        x = F.relu(self.conv1(x, edge_index))
        x = F.relu(self.conv2(x, edge_index))
        x = F.relu(self.conv3(x, edge_index))

        # Global pooling
        x = global_mean_pool(x, batch)

        # MLP для финального предсказания
        return self.mlp(x)

class ChainCoverTrainer:
    def __init__(self, dataset):
        self.dataset = dataset
        self.device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
        self.model = GraphCoverPredictor().to(self.device)

    def prepare_data(self):
        """Подготовка данных для обучения"""
        data_list = []

        for i, (G, optimal_cover) in enumerate(zip(self.dataset.graphs, self.dataset.optimal_covers)):
            # Преобразуем networkx граф в PyTorch Geometric формат
            pyg_graph = from_networkx(G)

            # Добавляем признаки вершин (используем degree как простой признак)
            degrees = torch.tensor([[d] for n, d in G.degree()], dtype=torch.float)
            pyg_graph.x = degrees

            # Целевое значение - количество цепей в оптимальном покрытии
            pyg_graph.y = torch.tensor([len(optimal_cover)], dtype=torch.float)

            data_list.append(pyg_graph)

        return data_list

    def train(self, num_epochs=130):
        """Обучение модели"""
        data_list = self.prepare_data()

        # Разделение на train/val
        train_size = int(0.8 * len(data_list))
        train_dataset = data_list[:train_size]
        val_dataset = data_list[train_size:]

        train_loader = DataLoader(train_dataset, batch_size=32, shuffle=True)
        val_loader = DataLoader(val_dataset, batch_size=32)

        optimizer = torch.optim.Adam(self.model.parameters(), lr=0.001)
        criterion = nn.MSELoss()

        best_val_loss = float('inf')

        # Списки для хранения истории обучения
        history = {
            'train_loss': [],
            'val_loss': [],
            'train_mae': [],
            'val_mae': []
        }

        for epoch in range(num_epochs):
            # Обучение
            self.model.train()
            total_loss = 0
            train_predictions = []
            train_targets = []

            for batch in train_loader:
                batch = batch.to(self.device)
                optimizer.zero_grad()

                out = self.model(batch.x, batch.edge_index, batch.batch)
                loss = criterion(out, batch.y)

                loss.backward()
                optimizer.step()
                total_loss += loss.item()

                train_predictions.extend(out.cpu().detach().numpy())
                train_targets.extend(batch.y.cpu().numpy())

            # Вычисляем MAE для тренировочной выборки
            train_mae = np.mean([abs(p - t) for p, t in zip(train_predictions, train_targets)])

            # Валидация
            self.model.eval()
            val_loss = 0
            val_predictions = []
            val_targets = []

            with torch.no_grad():
                for batch in val_loader:
                    batch = batch.to(self.device)
                    out = self.model(batch.x, batch.edge_index, batch.batch)

                    val_loss += criterion(out, batch.y).item()
                    val_predictions.extend(out.cpu().numpy())
                    val_targets.extend(batch.y.cpu().numpy())

            val_mae = np.mean([abs(p - t) for p, t in zip(val_predictions, val_targets)])

            # Сохраняем метрики
            history['train_loss'].append(total_loss/len(train_loader))
            history['val_loss'].append(val_loss/len(val_loader))
            history['train_mae'].append(train_mae)
            history['val_mae'].append(val_mae)

            if (epoch + 1) % 10 == 0:
                print(f'Epoch {epoch+1}/{num_epochs}:')
                print(f'Train Loss: {history["train_loss"][-1]:.4f}')
                print(f'Val Loss: {history["val_loss"][-1]:.4f}')
                print(f'Train MAE: {train_mae:.4f}')
                print(f'Val MAE: {val_mae:.4f}')

            if val_loss < best_val_loss:
                best_val_loss = val_loss
                torch.save(self.model.state_dict(), 'best_model.pt')

        # Визуализация процесса обучения
        plt.figure(figsize=(12, 5))

        # График функции потерь
        plt.subplot(1, 2, 1)
        plt.plot(history['train_loss'], label='Train Loss')
        plt.plot(history['val_loss'], label='Validation Loss')
        plt.xlabel('Epoch')
        plt.ylabel('Loss (MSE)')
        plt.title('Learning Curves - Loss')
        plt.legend()
        plt.grid(True)

        # График MAE
        plt.subplot(1, 2, 2)
        plt.plot(history['train_mae'], label='Train MAE')
        plt.plot(history['val_mae'], label='Validation MAE')
        plt.xlabel('Epoch')
        plt.ylabel('MAE')
        plt.title('Learning Curves - MAE')
        plt.legend()
        plt.grid(True)

        plt.tight_layout()
        plt.show()

        return history

    def predict(self, G):
        """Предсказание количества цепей для нового графа"""
        self.model.eval()

        # Подготовка графа
        pyg_graph = from_networkx(G)
        degrees = torch.tensor([[d] for n, d in G.degree()], dtype=torch.float)
        pyg_graph.x = degrees

        # Создаем batch из одного графа
        loader = DataLoader([pyg_graph], batch_size=1)
        batch = next(iter(loader)).to(self.device)

        with torch.no_grad():
            pred = self.model(batch.x, batch.edge_index, batch.batch)

        return int(pred.item() + 0.5)  # округляем до ближайшего целого

# Создаем тренера и обучаем модель
trainer = ChainCoverTrainer(dataset)
trainer.train()

# Тестируем на новом графе
test_graph = nx.gnp_random_graph(120, 0.2)
while not nx.is_connected(test_graph):
    test_graph = nx.gnp_random_graph(120, 0.2)

predicted_chains = trainer.predict(test_graph)
actual_chains = len(dataset.find_optimal_cover(test_graph))

print("\nРезультаты тестирования:")
print(f"Предсказанное количество цепей: {predicted_chains}")
print(f"Фактическое количество цепей: {actual_chains}")
print(f"Отклонение: {abs(predicted_chains - actual_chains)}")

class GraphDataset:
    def __init__(self, graphs):
        self.graphs = []

        for i in range(len(graphs):
            # Генерируем случайный связный граф
            self.graphs.append(G[i])
            break





import networkx as nx
import random
import numpy as np
from typing import List, Set, Tuple
import matplotlib.pyplot as plt
from collections import defaultdict

class GraphDataset:
    def __init__(self, num_graphs=200, min_vertices=100, max_vertices=150):
        self.graphs = []
        self.chain_covers = []
        self.optimal_covers = []


    def find_chain_cover(self, G: nx.Graph) -> List[List[int]]:
        """Находит покрытие графа непересекающимися цепями"""
        remaining_vertices = set(G.nodes())
        chains = []

        while remaining_vertices:
            # Начинаем новую цепь
            current_chain = []
            start_vertex = random.choice(list(remaining_vertices))
            current_chain.append(start_vertex)
            remaining_vertices.remove(start_vertex)

            while True:
                # Ищем следующую вершину для цепи
                current = current_chain[-1]
                neighbors = set(G.neighbors(current)) & remaining_vertices

                if not neighbors:
                    break

                next_vertex = random.choice(list(neighbors))
                current_chain.append(next_vertex)
                remaining_vertices.remove(next_vertex)

            chains.append(current_chain)

        return chains


    def generate_dataset(self):
        """Генерирует датасет с покрытиями для всех графов"""
        for G in self.graphs:
            chain_cover = self.find_chain_cover(G)
            optimal_cover = self.find_optimal_cover(G)
            self.chain_covers.append(chain_cover)
            self.optimal_covers.append(optimal_cover)


# Создаём и анализируем датасет
dataset = GraphDataset(num_graphs=200)
dataset.generate_dataset()
stats = dataset.analyze_covers()

print("Статистический анализ:")
print(f"Среднее количество цепей в покрытии: {stats['chain_mean']:.2f} ± {stats['chain_std']:.2f}")
print(f"Среднее количество цепей в оптимальном покрытии: {stats['optimal_mean']:.2f} ± {stats['optimal_std']:.2f}")

# Визуализация одного из графов
def visualize_graph(G: nx.Graph, chains: List[List[int]] = None):
    pos = nx.spring_layout(G)  # Расположение узлов

    # Рисуем граф
    plt.figure(figsize=(12, 8))
    nx.draw(G, pos, with_labels=True, node_color='lightblue', edge_color='gray', node_size=500, font_size=10)

    if chains:
        # Если переданы цепи, выделяем их разными цветами
        colors = plt.cm.get_cmap('tab10', len(chains))
        for i, chain in enumerate(chains):
            edges = [(chain[j], chain[j+1]) for j in range(len(chain)-1)]
            nx.draw_networkx_edges(G, pos, edgelist=edges, edge_color=[colors(i)], width=2)

    plt.title("Визуализация графа")
    plt.show()

# Визуализируем первый граф и его цепное покрытие
sample_graph = dataset.graphs[0]
sample_cover = dataset.chain_covers[0]
visualize_graph(sample_graph, sample_cover)